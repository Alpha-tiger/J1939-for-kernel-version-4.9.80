diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
index cd4661a..98392f7 100644
--- a/include/uapi/linux/can/j1939.h
+++ b/include/uapi/linux/can/j1939.h
@@ -59,6 +59,7 @@ enum {
 	SO_J1939_PROMISC = 2,	/* set/clr promiscuous mode */
 	SO_J1939_RECV_OWN = 3,
 	SO_J1939_SEND_PRIO = 4,
+	SO_J1939_BAM_DELAY_DISABLE = 5, //Enable/Disable 50 ms delay for BAM messages
 };
 
 enum {
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index da37056..8921236 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -205,7 +205,9 @@ struct j1939_sk_buff_cb {
 	int dst_flags;
 
 #define ECU_LOCAL 1
-
+	/*  Flags for modifying the transport protocol*/ 
+	int tpflags;
+#define BAM_NODELAY 1
 	/* for tx, MSG_SYN will be used to sync on sockets */
 	int msg_flags;
 
@@ -223,6 +225,23 @@ static inline struct j1939_sk_buff_cb *j1939_get_cb(struct sk_buff *skb)
 	return (struct j1939_sk_buff_cb *)skb->cb;
 }
 
+
+//Check if we want to disable the normal BAM 50 ms delay
+//Return 0 if we want to disable the delay
+//Return 1 if we want to keep the delay
+static inline int j1939cb_use_bamdelay(const struct j1939_sk_buff_cb *skcb)
+{
+	//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+	//printk(KERN_ALERT "DEBUG: skcb->tpflags state: %d\n",skcb->tpflags);
+
+	if(skcb->tpflags & BAM_NODELAY)
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
 static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 {
 	return (!skcb->addr.dst_name && (skcb->addr.da == 0xff));
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 86cdcc1..340257d 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -126,8 +126,10 @@ int j1939_send(struct sk_buff *skb)
 	struct can_frame *cf;
 
 	if (skb->len > 8)
+	{
 		/* re-route via transport protocol */
 		return j1939_send_transport(skb);
+	}
 
 	/* apply sanity checks */
 	skcb->addr.pgn &= (pgn_is_pdu1(skcb->addr.pgn)) ? 0x3ff00 : 0x3ffff;
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index e04c171..0d66234 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -40,6 +40,7 @@ struct j1939_sock {
 #define J1939_SOCK_CONNECTED BIT(1)
 #define J1939_SOCK_PROMISC BIT(2)
 #define J1939_SOCK_RECV_OWN BIT(3)
+#define J1939_SOCK_BAM_DELAY BIT(4)
 
 	struct j1939_addr addr;
 	struct j1939_filter *filters;
@@ -480,6 +481,13 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 		jsk->sk.sk_priority = j1939_to_sk_priority(tmp);
 		release_sock(&jsk->sk);
 		return 0;
+	case SO_J1939_BAM_DELAY_DISABLE:
+		//Enables/Disables delay
+		tmp = j1939sk_setsockopt_flag(jsk, optval, optlen, J1939_SOCK_BAM_DELAY);
+		//printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+		//printk("DEBUG: SO_J1939_BAM_DELAY_DISABLE used with value: %d\n",tmp);
+		//printk("DEBUG: jsk->state: %d\n",(int)(jsk->state));
+		return tmp;
 	default:
 		return -ENOPROTOOPT;
 	}
@@ -514,6 +522,9 @@ static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
 	case SO_J1939_SEND_PRIO:
 		tmp = j1939_prio(jsk->sk.sk_priority);
 		break;
+	case SO_J1939_BAM_DELAY_DISABLE:
+		tmp = (jsk->state &  J1939_SOCK_BAM_DELAY) ? 1 : 0;
+		break;
 	default:
 		ret = -ENOPROTOOPT;
 		goto no_copy;
@@ -655,6 +666,12 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	skcb->priority = j1939_prio(sk->sk_priority);
 	skcb->msg_flags = msg->msg_flags;
 
+	
+	//Check if delay has been disabled
+	skcb->tpflags = (jsk->state & J1939_SOCK_BAM_DELAY)?BAM_NODELAY:0;
+	//printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+	//printk("DEBUG: skcb->tpflags state: %d\n",skcb->tpflags);
+
 	if (msg->msg_name) {
 		struct sockaddr_can *addr = msg->msg_name;
 
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 587eb04..4dfb40e 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -953,7 +953,18 @@ static int j1939tp_txnext(struct session *session)
 		session->last_txcmd = dat[0];
 		/* must lock? */
 		if (tp_cmd_bam == dat[0])
-			j1939tp_schedule_txtimer(session, 50);
+		{
+			//Use  50 ms delay
+			if(j1939cb_use_bamdelay(session->cb))
+			{
+				j1939tp_schedule_txtimer(session, 50);
+			}
+			//Don't use bam delay
+			else
+			{
+				j1939tp_schedule_txtimer(session,1);
+			}
+		}
 		j1939tp_set_rxtimeout(session, 1250);
 		break;
 	case tp_cmd_rts:
@@ -1063,8 +1074,17 @@ static int j1939tp_txnext(struct session *session)
 			session->last_txcmd = 0xff;
 			++pkt_done;
 			++session->pkt.tx;
-			pdelay = j1939cb_is_broadcast(session->cb) ?  50 :
-				packet_delay;
+
+			if(j1939cb_is_broadcast(session->cb) && j1939cb_use_bamdelay(session->cb))
+			{
+				pdelay = 50;
+			}
+			else
+			{
+				pdelay = packet_delay;
+			}
+
+
 			if ((session->pkt.tx < session->pkt.total) && pdelay) {
 				j1939tp_schedule_txtimer(session, pdelay);
 				break;
