diff --git a/Documentation/networking/j1939.txt b/Documentation/networking/j1939.txt
new file mode 100644
index 0000000..fbf0d8a
--- /dev/null
+++ b/Documentation/networking/j1939.txt
@@ -0,0 +1,576 @@
+============================================================================
+
+j1939.txt
+
+Readme file for the J1939 Protocol
+
+This file contains
+
+  1 Overview / What is j1939
+    1.1 specifications used
+
+  2 Motivation
+
+  3 J1939 concepts
+    3.1 socket type
+    3.2 addressing
+    3.3 priority
+    3.4 PGN
+    3.5 filtering
+    3.6 destinations with dynamic address
+
+  4 How to use J1939
+    4.1 rtnetlink interface
+    4.2 API calls
+        4.2.1 Message flags during sendmsg
+	4.2.2 SCM_J1939_DEST_ADDR & SCM_J1939_DEST_NAME
+	4.2.3 SCM_J1939_PRIORITY
+    4.3 Dynamic addressing
+    4.4 Send Examples
+        4.4.1 Static address
+	4.4.2 Dynamic address
+	4.4.3 Mixed mode
+
+  5 socket options
+    5.1 SO_J1939_FILTER
+    5.2 SO_J1939_PROMISC
+    5.3 SO_J1939_RECV_OWN
+    5.4 SO_J1939_SEND_PRIO
+
+  6 can-j1939 procfs interface
+    6.1 /proc/net/can-j1939/ecu
+    6.2 /proc/net/can-j1939/filter
+    6.3 /proc/net/can-j1939/sock
+    6.4 /proc/net/can-j1939/transport
+
+  7 can-j1939 SYSCTL
+    7.1 /proc/sys/net/can-j1939/transport_max_payload_in_bytes
+    7.2 /proc/sys/net/can-j1939/transport_cts_nr_of_frames
+    7.3 /proc/sys/net/can-j1939/transport_tx_retry_ms
+
+  8 Credits
+
+============================================================================
+
+1. Introduction
+--------------------------------
+
+  SAE J1939 defines a higher layer protocol on CAN. It implements a more
+  sophisticated addressing scheme and extends the maximum packet size above
+  8 bytes. Several derived specifications exists, which differ from the
+  original j1939 on the application level, like MilCAN, NMEA2000 and
+  especially ISO-11783 (ISOBUS). This last one specifies the so-called ETP
+  (Extended Transport Protocol) which is has been included in this
+  implementation. This inclusion results in a maximum packet size of
+  ((2^24)-1)*7 bytes
+
+
+1.1 specifications used
+
+  SAE J1939-21 : data link layer
+  SAE J1939-81 : network management
+  ISO 11783-6  : Virtual Terminal (Extended Transport Protocol)
+
+
+2. Motivation
+--------------------------------
+
+  Given the fact there's something like SocketCAN with an API similar to BSD
+  sockets, we found some reasons to justify a kernel implementation for the
+  addressing and transport methods used by J1939.
+
+  * addressing:
+    When a process on an ECU communicates via j1939, it should not necessarily
+    know its source address. Although at least 1 process per ECU should know
+    the source address. Other processes should be able to reuse that address.
+    This way, address parameters for different processes cooperating for the
+    same ECU, are not duplicated.
+    This way of working is closely related to the unix concept where programs
+    do just 1 thing, and do it well.
+
+  * dynamic addressing:
+    Address Claiming in J1939 is time critical. Furthermore data transport
+    should be handled properly during the address negotiation. Putting these
+    functionality in the kernel eliminates this functionality as a requirement
+    for _every_ userspace process that communicates via J1939. This results in
+    a consistent J1939 bus with proper addressing.
+
+  * transport:
+    Both TP & ETP reuse some PGN's to relay big packets over them. Different
+    processes may thus use the same TP & ETP PGN's without actually knowing it.
+    The individual TP & ETP sessions _must_ be serialized (synchronised)
+    between different processes. The kernel solves this problem properly, and
+    eliminates the serialisation (synchronisation) as a requirement for
+    _every_ userspace process that communicates via J1939.
+
+  J1939 defines some other features (relaying, gateway, Fast Packet transport,
+  ...). In-kernel code for these would not contribute to protocol stability.
+  Therefore, these parts are left to userspace.
+
+  The j1939 sockets operate on CAN network devices (see SocketCAN). Any j1939
+  userspace library operating on CAN raw sockets will still operate properly.
+  Since such library does not communicate with the in-kernel implementation,
+  care must be taken that these 2 do not interfere. In practice, this means
+  they cannot share ECU addresses. A single ECU (or virtual ECU) address is
+  used by the library exclusively, or by the in-kernel system exclusively.
+
+
+3. J1939 concepts
+--------------------------------
+
+3.1 PGN
+
+  The PGN (Parameter Group Number) is a number to identify a packet. The PGN
+  is composed as follows:
+   1 bit  : Reserved Bit
+   1 bit  : Data Page
+   8 bits : PF (PDU Format)
+   8 bits : PS (PDU Specific)
+
+  In J1939-21, distinction is made between PDU1 Format (where PF < 240) and
+  PDU2 Format (where PF >= 240). Furthermore, when using PDU2 Format, the
+  PS-field contains a so-called Group Extension, which is part of the PGN.
+  When using PDU2 Format, the Group Extension is set in the PS-field.
+
+  On the other hand, when using PDU1 Format, the PS-field contains a so-called
+  Destination Address, which is _not_ part of the PGN. When communicating a
+  PGN from userspace to kernel (or visa versa) and PDU2 Format is used, the
+  PS-field of the PGN shall be set to zero. The Destination Address shall be
+  set elsewhere.
+
+  Regarding PGN mapping to 29-bit CAN identifier, the Destination Address
+  shall be get/set from/to the appropriate bits of the identifier by the kernel.
+
+
+3.2 addressing
+
+  Both static and dynamic addressing methods can be used.
+
+  For static addresses, no extra checks are made by the kernel, and provided
+  addresses are considered right. This responsibility is for the OEM or system
+  integrator.
+
+  For dynamic addressing, so-called Address Claiming, extra support is forseen
+  in the kernel. In J1939 any ECU is known by it's 64-bit NAME. At the moment
+  of succesfull address claim, the kernel keeps track of both NAME and source
+  address being claimed. This serves as a base for filter schemes. By default,
+  packets with a destination that is not locally, will be rejected soon after
+  reception.
+
+  Mixed mode packets (from a static to a dynamic address or vice versa) are
+  allowed. The BSD sockets define separate API calls for getting/setting the
+  local & remote address and are applicable for J1939 sockets.
+
+
+3.3 Filtering
+
+  Similar to SocketCAN, j1939 defines filters per socket that a user can set
+  in order to receive a subset of the j1939 traffic. Filtering can base on
+  * SA
+  * NAME
+  * PGN
+
+  There is a semantic difference with SocketCAN with regard to filtering.
+  When multiple filters are in place for a single socket, and a packet comes
+  in that matches several of those filters, the packet is only received once
+  for that socket.
+  The rationale behind this difference originates in the filter capabilities.
+  Where SocketCAN filters on only 1 orthogonal (can id), J1939 can filter
+  on 3 orthogonal properties (sa, name, pgn).
+
+  When a filter on the SA is set, j1939 traffic with a matching SA, but with
+  its NAME set (aka having claimed SA successfully) will match, although
+  the filter would not match its NAME.
+
+  Filtering on priority is _not_ supported.
+
+
+4. How to use J1939
+--------------------------------
+
+4.1 rtnetlink interface
+
+  Per default j1939 is not active. Specifying can_ifindex != 0 in bind(2)
+  or connect(2) needs an active j1939 on that interface. You must have done
+  $ ip link set canX j1939 on
+  on that interface.
+
+  $ ip link set canX j1939 off
+  disables j1939 on canX.
+
+  Assigning addresses is done via
+  $ ip addr add dev canX j1939 0xXX
+  statically or
+  $ ip addr add dev canX j1939 name 0xXX
+  dynamically. In the latter case, address claiming must take place
+  before other traffic can leave.
+
+  Removing addresses is done similarly via
+  $ ip addr del dev canX j1939 0xXX
+  $ ip addr del dev canX j1939 name 0xXX
+
+  A static address cannot be assigned together with a 64bit name.
+
+4.2 API calls
+
+  Like TCP/IP and CAN, you first need to open a socket for communicating over a
+  CAN network. To use j1939, include <include/linux/j1939.h>. From there,
+  <include/linux/can.h> will be included too.
+  To open a socket, you would write
+
+    s = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);
+
+  J1939 does use SOCK_DGRAM sockets. In the j1939 specification, connections are
+  mentioned in the context of transport protocol sessions. These still deliver
+  packets to the other end (using several CAN packets).
+  SOCK_STREAM is never appropriate.
+
+  After the successful creation of the socket, you would normally use the
+  bind(2) and/or connect(2) system call to bind the socket to a CAN interface
+  (which is different from TCP/IP due to different addressing) After binding
+  and/or connecting the socket, you can read(2) and write(2) from/to the socket
+  or use send(2), sendto(2), sendmsg(2) and the recv* counterpart operations on
+  the socket as usual. There are also J1939 specific socket options described
+  below.
+
+  In order to send data, a bind(2) must have succeeded. bind(2) assigns a local
+  address to a socket. For this to succeed, you can only choose addresses
+  that have been assigned earlier (see 4.1). When an empty address is assigned
+  (ie. SA=0xff && name=0), a default is taken for the device that is bound to.
+
+  Different from CAN is that the payload data is just the data that get send,
+  without it's header info. The header info is derived from the sockaddr
+  supplied to bind(2), connect(2), sendto(2) and recvfrom(2). A write(2) with
+  size 4 will result in a packet with 4 bytes.
+
+  The sockaddr structure has extensions for use with j1939 as specified below:
+      struct sockaddr_can {
+         sa_family_t can_family;
+         int         can_ifindex;
+         union {
+            struct {
+               __u64 name;
+               __u32 pgn;
+               __u8  addr;
+            } j1939;
+         } can_addr;
+      }
+
+  can_family & can_ifindex serve the same purpose as for other SocketCAN sockets.
+
+  can_addr.j1939.pgn specifies the PGN (max 0x3ffff). Individual bits are
+  specified above.
+
+  can_addr.j1939.name contains the 64-bit J1939 NAME.
+
+  can_addr.j1939.addr contains the source address.
+
+  When sending data, the source address is applied as follows: If
+  can_addr.j1939.name != 0 the NAME is looked up by the kernel and the
+  corresponding Source Address is used. If can_addr.j1939.name == 0,
+  can_addr.j1939.addr is used.
+
+  After a bind(2), the local address is assigned, i.e. the source address.
+  After a connect(2), the remote address is assigned, i.e. the destination
+  address.
+
+  Both write(2) and send(2) will send a packet with local address from bind,
+  remote address from connect(2). When the address was not set, a broadcast is
+  sent. The PGN is used from bind(2) or overruled with sendto(2), which will
+  override the destination address when valid, and the PGN when valid.
+
+  Both read(2) and recv(2) will receive packets matching the sockets filters.
+  recvfrom(2) will receive these packets with originator's address.
+
+  When creating a socket, reasonable defaults have been set. Some options can be
+  modified with setsockopt(2) & getsockopt(2).
+
+4.2.1 Message flags during sendmsg
+
+  send(2), sendto(2) and sendmsg(2) take a 'flags' argument. J1939 interpretes
+  these flags during outgoing traffic:
+
+  * MSG_DONTWAIT determines nonblocking operation. When a packet must wait for
+    any reason, -EAGAIN is returned.
+
+  * MSG_SYN
+    Packets flagged with MSG_SYN will wait for all pending packets on a socket
+    to be sent before trying to send. This means that if a socket just started
+    a Transport Protocol session, a packet with MSG_SYN will wait for that
+    session to complete before proceeding.
+    Traffic without MSG_SYN (on that very same socket) will still continue.
+
+4.2.2 SCM_J1939_DEST_ADDR & SCM_J1939_DEST_NAME
+
+  Different received j1939 packets could have had different destionations:
+  - broadcast packet, i.e. no destination address
+  - destination address that matches the sockets local address
+  - destination address that matches _a_ local address on the system, and the
+    socket had no local address defined.
+  - SO_J1939_PROMISC was set
+
+  The destination address & destination name (if applicable) are attached
+  to the msghdr in the recvmsg(2) call. It can be extracted using cmsg(3) macros,
+  with cmsg_level == SOL_J1939 && cmsg_type == SCM_J1939_DEST_ADDR
+  or SCM_J1939_DEST_NAME. The returned data is a uint8_t/uint64_t.
+
+4.2.3 SCM_J1939_PRIORITY
+
+  Attached to the msghdr is also the packet's priority on the bus. This is a
+  uint8_t, packed as cmsg_type == SCM_J1939_PRIORITY.
+
+4.3 Dynamic Addressing
+
+  Distinction has to be made in and using the claimed address and doing an
+  address claim. To use an already claimed address, one has to fill in the
+  j1939.name member and provide it to bind(2). If the name had claimed an
+  address earlier, all further PGN's being sent will use that address. And the
+  j1939.addr member will be ignored.
+
+  An exception on this is pgn 0x0ee00. This is the "Address Claim/Cannot Claim
+  Address" message and when the kernel will use the j1939.addr member for that
+  pgn if necessary.
+
+  To claim an address, bind(2) with:
+  j1939.pgn  set to 0x0ee00
+  j1939.addr set to the desired Source Address.
+  j1939.name set to the NAME you want the Source Address to claim to.
+
+  Afterwards do a write(2) with data set to the NAME (Little Endian). If the
+  NAME provided, does not match the j1939.name provided to bind(2), EPROTO
+  will be returned. One might use sendto(2) also to send the Address Claim. In
+  that case, the j1939.addr member must be set to the broadcast address (255)
+  and the j1939.pgn must be set to 0x0ee00. If This combination is not given,
+  EPROTO is returned.
+
+  If no-one else contest the address claim within 250ms after transmission, the
+  kernel marks the NAME-SA assignment as valid. The valid assignment will be
+  kept, among other valid NAME-SA assignments. From that point, any socket
+  bound to the NAME can send packets.
+
+  If another ECU claims the address, the kernel will mark the NAME-SA expired.
+  No socket bound to the NAME can send packets (other than address claims).
+  To claim another address, some socket bound to NAME, must bind(2) again,
+  but with only j1939.addr changed to the new SA, and must then send a
+  valid address claim packet. This restarts the state machine in the kernel
+  (and any other participant on the bus) for this NAME.
+
+
+4.4 Send Examples
+
+4.4.1 Static addressing
+
+  This example will send a pgn (0x12300) from SA 0x20 to DA 0x30.
+
+  Add the address to the system:
+  $ ip addr add j1939 0x20 dev can0
+
+  Bind:
+    struct sockaddr_can addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.can_ifindex = ifindex("can0"); // ifindex is a substitute.
+    addr.can_addr.j1939.name = J1939_NO_NAME;
+    addr.can_addr.j1939.addr = 0x20;
+    addr.can_addr.j1939.pgn = J1939_NO_PGN;
+
+    bind(sk, (void *)&addr, sizeof(addr));
+
+  Now, the socket 'sk' is bound to the address 0x20. Since no pgn
+  was specified during bound, a pgn will be necessary during sendto() operations.
+  Alternatively, specifying addr.can_addr.j1939.pgn during bind() allows
+  for using send() & write(), since a default pgn (the pgn specified during bind())
+  can be used then.
+
+  Send:
+    struct sockaddr_can addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.can_addr.j1939.name = J1939_NO_NAME;
+    addr.can_addr.j1939.addr = 0x30;
+    addr.can_addr.j1939.pgn = 0x12300;
+    // addr.can_ifindex is not necessary here.
+
+    sendto(sk, data, sizeof(data), 0, (void *)&addr, sizeof(addr));
+
+4.4.2 Dynamic addressing
+
+  This example will send a pgn (0x12300) from 12345678 to 9ABCDEF
+
+  Add the name to the system:
+  $ ip addr add j1939 name 12345678 dev can0
+
+  Start an address claiming daemon (e.g. jacd)
+  $ jacd -r 0x20-0x30 12345678 can0 &
+
+  Bind:
+    struct sockaddr_can addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.can_ifindex = ifindex("can0"); // ifindex is a substitute.
+    addr.can_addr.j1939.name = 0x12345678ULL;
+    addr.can_addr.j1939.addr = J1939_NO_ADDR;
+    addr.can_addr.j1939.pgn = J1939_NO_PGN;
+
+    bind(sk, (void *)&addr, sizeof(addr));
+
+  Send:
+    struct sockaddr_can addr;
+
+    memset(&addr, 0, sizeof(addr));
+    addr.can_addr.j1939.name = 0x9ABCDEFULL;
+    addr.can_addr.j1939. = J1939_NO_ADDR;
+    addr.can_addr.j1939.pgn = 0x12300;
+
+    sendto(sk, data, sizeof(data), 0, (void *)&addr, sizeof(addr));
+
+4.4.3 Mixed mode
+
+  A scenario that sends a packet from a static address to a dynamic address
+  or vice versa is called 'mixed mode' here.
+
+  Combining the setup of the static address with a sendto() to a dynamic
+  address from the above examples is legal, and implements such mixed mode
+  addressing. The same applies for the setup of the dynamic address combined
+  with the sendto() towards a dynamic address.
+
+
+5 Socket Options
+--------------------------------
+
+  j1939 sockets have some options that are configurable via setsockopt(2).
+  Each of those options is initialized with a reasonable default.
+
+
+5.1 SO_J1939_FILTER
+
+  As mentioned above, J1939 supports filtering in both NAME, Source Address
+  and PGN. All members must match.
+
+   struct j1939_filter filter = {
+      .name         = ...
+      .name_mask   = ...
+      .addr         = ...
+      .addr_mask   = ...
+      .pgn         = ...
+      .pgn_mask   = ...
+   }
+
+    setsockopt(s, SOL_CAN_J1939, SO_J1939_FILTER, &filter, sizeof(filter));
+
+
+5.2 SO_J1939_PROMISC
+
+  When set, j1939 will receive all packets, not just those with a destination
+  on the local system.
+  default off.
+
+    int promisc = 1; /* 0 = disabled (default), 1 = enabled */
+
+    setsockopt(s, SOL_CAN_J1939, SO_J1939_PROMISC, &promisc, sizeof(promisc));
+
+
+5.3 SO_J1939_RECV_OWN
+
+  All the sent j1939 packets are looped back in the system.
+  The reception of the j1939 packets on the same socket that was
+  sending the j1939 packet is assumed to be unwanted and therefore
+  disabled by default. This default behaviour may be changed on
+  demand:
+
+    int recv_own_msgs = 1; /* 0 = disabled (default), 1 = enabled */
+
+    setsockopt(s, SOL_CAN_J1939, SO_J1939_RECV_OWN,
+               &recv_own_msgs, sizeof(recv_own_msgs));
+
+
+5.4 SO_J1939_SEND_PRIO
+
+  To set the priority field for outgoing packets, the SO_J1939_SEND_PRIO can
+  be changed. This int field specifies the priority that will be used.
+  j1939 defines a priority between 0 and 7 inclusive,
+  with 7 the lowest priority.
+  Per default, the priority is set to 6 (conforming J1939).
+  This priority socket option operates on the same value that is modified
+  with
+
+    setsockopt(s, SOL_SOCKET, SO_PRIORITY, &pri, sizeof(pri))
+
+  socketoption, with a difference that SOL_SOCKET/SO_PRIORITY is defined with
+  0 the lowest priority. SOL_CAN_J1939/SO_J1939_SEND_PRIO inverts this value
+  for you.
+
+
+6. /proc/net/can-j1939 Interface.
+--------------------------------
+
+  Files giving you a view on the in-kernel operation of J1939 are located at:
+  /proc/net/j1939.
+
+6.1 /proc/net/can-j1939/ecu
+
+  This file gives an overview of the known ECU's to the kernel.
+  - iface : network interface they operate on.
+  - SA : current address.
+  - name : 64bit NAME
+  - flags : 'L' = local, 'R' = remote
+
+6.2 /proc/net/can-j1939/filter
+
+6.3 /proc/net/can-j1939/sock
+
+  This file gives a list of all j1939 sockets currently open.
+  - iface : network interface
+  - flags :
+    'b' : bound
+    'c' : connected
+    'P' : PROMISC
+    'o' : RECV_OWN
+    'd' : RECV_DEST
+    'p' : RECV_PRIO
+  - local: [NAME],SA
+  - remote: [NAME]/MASK,DA
+  - pgn : PGN
+  - prio : priority
+  - pending : # packets pending (see MSG_SYN on 4.2.1)
+
+6.4 /proc/net/can-j1939/transport
+
+  This file shows a list of pending transport sessions
+  - iface
+  - src : XX (addr) or XXXXXXXXXXXXXXXX (name)
+  - dst : XX or XXXXXXXXXXXXXXXX or '-' (broadcast)
+  - pgn :
+  - done/total : current # transferred bytes / total
+
+
+7. /proc/sys/net/can-j1939 - SYSCTL
+--------------------------------
+
+  Via these sysctl files, some parameters of the j1939 module can be tuned.
+
+7.1 /proc/sys/net/can-j1939/transport_max_payload_in_bytes [int]
+
+  Is the maximum packet size to accept on both transmit & receive side.
+  Bigger packets will be rejected (local sender), aborted (local receiver)
+  or ignored (broadcasts & remote recievers in PROMISC).
+
+7.2 /proc/sys/net/can-j1939/transport_cts_nr_frames [int]
+
+  Controls the number of packets to allow between consecutive CTS frames
+  (default 255).
+  This number is communicated within the CTS frame from receiver to transmitter.
+  Setting this has effect on received transport sessions only.
+
+7.3 /proc/sys/net/can-j1939/transport_tx_retry_ms [int]
+
+  Controls how many time to wait before retrying to send an individual TP
+  flow or data packet after transmission failure (default 20).
+
+
+8. Credits
+--------------------------------
+
+  Kurt Van Dijck (j1939 core, transport protocol, API)
+  Pieter Beyens (j1939 core, address claiming)
+
diff --git a/Documentation/sysctl/net.txt b/Documentation/sysctl/net.txt
index f0480f7..09bc881 100644
--- a/Documentation/sysctl/net.txt
+++ b/Documentation/sysctl/net.txt
@@ -27,6 +27,7 @@ Table : Subdirectories in /proc/sys/net
  ipx       IPX                 token-ring IBM token ring
  bridge    Bridging            decnet     DEC net
  ipv6      IP version 6        tipc       TIPC
+ can-j1939 SAE J1939
 ..............................................................................
 
 1. /proc/sys/net/core - Network core options
@@ -315,3 +316,48 @@ originally may have been issued in the correct sequential order.
 If named_timeout is nonzero, failed topology updates will be placed on a defer
 queue until another event arrives that clears the error, or until the timeout
 expires. Value is in milliseconds.
+
+7. SAE J1939
+-------------------------------------------------------
+
+transport_burst_count
+---------------------
+
+This tunable controls how many fragments to receive in a burst for the transport
+protocol. The value must be between 1 and 255. Transport protocol is more
+efficient with higher values, therefore, the default is 255.
+
+transport_max_size
+------------------
+
+The kernel needs to allocate a buffer for each packet received with transport
+protocol, before it can decide that the packet is not needed locally.
+This tunable controls the maximum size for packets to allocate.
+Packets that are announced with a bigger size are not received, i.e. aborted
+for private transport protocol sessions, and ignored for broadcasted sessions.
+
+transport_retry_time
+--------------------
+
+After the first fragment of a transport protocol sessions has been sent, the
+subsequent fragments will be delivered to best effert, including a retry when
+recoverable failures pass.
+This parameter controls the time before a retry is attempted. The time is
+expressed in milliseconds.
+
+transport_packet_delay
+----------------------
+
+This parameter controls the time in milliseconds between outgoing fragments
+of a single transport protocol session. This is normally 0, which indicates
+as fast as possible. Slower ECU's on the bus may require a delay in order
+to keep up receiving fragments.
+
+transport_padding
+-----------------
+
+SAE J1939 requires transport protocol data fragments to fill all 8 bytes of
+the CAN frame, and to pad the unused bytes with 0xff.
+This parameters (default 1) allow to turn off (0) padding. The CAN frame's DLC
+is then adjusted. This increases effiency (a tiny bit), makes the packets on
+the wire easier to read, but break strict compliancy to the standard.
diff --git a/MAINTAINERS b/MAINTAINERS
index 63cefa6..8a22cd0 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2924,6 +2924,15 @@ F:	include/linux/can/platform/
 F:	include/uapi/linux/can/error.h
 F:	include/uapi/linux/can/netlink.h
 
+CAN-J1939 NETWORK LAYER
+M:	Kurt Van Dijck <kurt.van.dijck@eia.be>
+L:	socketcan-core@lists.berlios.de
+L:	netdev@vger.kernel.org
+S:	Maintained
+F:	Documentation/networking/j1939.txt
+F:	net/can/j1939/
+F:	include/uapi/linux/can/j1939.h
+
 CAPABILITIES
 M:	Serge Hallyn <serge@hallyn.com>
 L:	linux-security-module@vger.kernel.org
diff --git a/include/linux/can/core.h b/include/linux/can/core.h
index df08a41..d17d525 100644
--- a/include/linux/can/core.h
+++ b/include/linux/can/core.h
@@ -16,6 +16,7 @@
 #include <linux/can.h>
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
+#include <net/rtnetlink.h>
 
 #define CAN_VERSION "20120528"
 
@@ -40,6 +41,14 @@ struct can_proto {
 	struct proto *prot;
 };
 
+/* required_size
+ * macro to find the minimum size of a struct
+ * that includes a requested member
+ */
+#define REQUIRED_SIZE(struct_type, member) \
+	(offsetof(typeof(struct_type), member) + \
+	 sizeof(((typeof(struct_type) *)(NULL))->member))
+
 /* function prototypes for the CAN networklayer core (af_can.c) */
 
 extern int  can_proto_register(const struct can_proto *cp);
diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h
index c48d93a..270ea3a 100644
--- a/include/uapi/linux/can.h
+++ b/include/uapi/linux/can.h
@@ -156,7 +156,8 @@ struct canfd_frame {
 #define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
 #define CAN_MCNET	5 /* Bosch MCNet */
 #define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
-#define CAN_NPROTO	7
+#define CAN_J1939	7 /* SAE J1939 */
+#define CAN_NPROTO	8
 
 #define SOL_CAN_BASE 100
 
@@ -171,7 +172,26 @@ struct sockaddr_can {
 	int         can_ifindex;
 	union {
 		/* transport protocol class address information (e.g. ISOTP) */
-		struct { canid_t rx_id, tx_id; } tp;
+		struct {
+			canid_t rx_id;
+			canid_t tx_id;
+		} tp;
+
+		/* J1939 address information */
+		struct {
+			/* 8 byte name when using dynamic addressing */
+			__u64 name;
+			/* pgn:
+			 * 8bit: PS in PDU2 case, else 0
+			 * 8bit: PF
+			 * 1bit: DP
+			 * 1bit: reserved
+			 */
+			__u32 pgn;
+
+			/* 1byte address */
+			__u8 addr;
+		} j1939;
 
 		/* reserved for future CAN protocols address information */
 	} can_addr;
diff --git a/include/uapi/linux/can/Kbuild b/include/uapi/linux/can/Kbuild
index 21c91bf..9149ff9 100644
--- a/include/uapi/linux/can/Kbuild
+++ b/include/uapi/linux/can/Kbuild
@@ -4,3 +4,4 @@ header-y += error.h
 header-y += gw.h
 header-y += netlink.h
 header-y += raw.h
+header-y += j1939.h
diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
new file mode 100644
index 0000000..6c974ba
--- /dev/null
+++ b/include/uapi/linux/can/j1939.h
@@ -0,0 +1,94 @@
+/*
+ * j1939.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _UAPI_CAN_J1939_H_
+#define _UAPI_CAN_J1939_H_
+
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/can.h>
+
+#define J1939_IDLE_ADDR	0xfe
+#define J1939_NO_ADDR 0xff
+#define J1939_NO_NAME 0
+#define J1939_NO_PGN 0x40000
+
+/* J1939 Parameter Group Number
+ *
+ * bit 0-7	: PDU Specific (PS)
+ * bit 8-15	: PDU Format (PF)
+ * bit 16	: Data Page (DP)
+ * bit 17	: Reserved (R)
+ * bit 19-31	: set to zero
+ */
+typedef __u32 pgn_t;
+
+/* J1939 Priority
+ *
+ * bit 0-2	: Priority (P)
+ * bit 3-7	: set to zero
+ */
+typedef __u8 priority_t;
+
+/* J1939 NAME
+ *
+ * bit 0-20	: Identity Number
+ * bit 21-31	: Manufacturer Code
+ * bit 32-34	: ECU Instance
+ * bit 35-39	: Function Instance
+ * bit 40-47	: Function
+ * bit 48	: Reserved
+ * bit 49-55	: Vehicle System
+ * bit 56-59	: Vehicle System Instance
+ * bit 60-62	: Industry Group
+ * bit 63	: Arbitrary Address Capable
+ */
+typedef __u64 name_t;
+
+/* J1939 socket options */
+#define SOL_CAN_J1939 (SOL_CAN_BASE + CAN_J1939)
+enum {
+	SO_J1939_FILTER = 1,	/* set filters */
+	SO_J1939_PROMISC = 2,	/* set/clr promiscuous mode */
+	SO_J1939_RECV_OWN = 3,
+	SO_J1939_SEND_PRIO = 4,
+	SO_J1939_BAM_DELAY_DISABLE = 5, //Enable/Disable 50 ms delay for BAM messages
+};
+
+enum {
+	SCM_J1939_DEST_ADDR = 1,
+	SCM_J1939_DEST_NAME = 2,
+	SCM_J1939_PRIO = 3,
+};
+
+struct j1939_filter {
+	name_t name;
+	name_t name_mask;
+	__u8 addr;
+	__u8 addr_mask;
+	pgn_t pgn;
+	pgn_t pgn_mask;
+};
+
+/* RTNETLINK */
+enum {
+	IFLA_J1939_UNSPEC,
+	IFLA_J1939_ENABLE,
+	IFLA_J1939_MAX,
+};
+
+enum {
+	IFA_J1939_UNSPEC,
+	IFA_J1939_ADDR,
+	IFA_J1939_NAME,
+	IFA_J1939_MAX,
+};
+
+#endif /* !_UAPI_CAN_J1939_H_ */
diff --git a/net/can/Kconfig b/net/can/Kconfig
index a15c0e0..85df900 100644
--- a/net/can/Kconfig
+++ b/net/can/Kconfig
@@ -51,6 +51,8 @@ config CAN_GW
 	  They can be modified with AND/OR/XOR/SET operations as configured
 	  by the netlink configuration interface known e.g. from iptables.
 
+source "net/can/j1939/Kconfig"
+
 source "drivers/net/can/Kconfig"
 
 endif
diff --git a/net/can/Makefile b/net/can/Makefile
index 1093675..14f0914 100644
--- a/net/can/Makefile
+++ b/net/can/Makefile
@@ -14,3 +14,5 @@ can-bcm-y		:= bcm.o
 
 obj-$(CONFIG_CAN_GW)	+= can-gw.o
 can-gw-y		:= gw.o
+
+obj-$(CONFIG_CAN_J1939)	+= j1939/
diff --git a/net/can/af_can.h b/net/can/af_can.h
index b86f512..d04ffeb 100644
--- a/net/can/af_can.h
+++ b/net/can/af_can.h
@@ -73,6 +73,9 @@ struct dev_rcv_lists {
 	struct hlist_head rx_eff[CAN_EFF_RCV_ARRAY_SZ];
 	int remove_on_zero_entries;
 	int entries;
+#ifdef CAN_J1939
+	void *j1939_priv;
+#endif
 };
 
 /* statistic structures */
diff --git a/net/can/bcm.c b/net/can/bcm.c
index e4f694d..0d2dad2 100644
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@ -1325,7 +1325,7 @@ static int bcm_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 		/* no bound device as default => check msg_name */
 		DECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);
 
-		if (msg->msg_namelen < sizeof(*addr))
+		if (msg->msg_namelen < REQUIRED_SIZE(*addr, can_ifindex))
 			return -EINVAL;
 
 		if (addr->can_family != AF_CAN)
@@ -1562,7 +1562,7 @@ static int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,
 	struct bcm_sock *bo = bcm_sk(sk);
 	int ret = 0;
 
-	if (len < sizeof(*addr))
+	if (len < REQUIRED_SIZE(*addr, can_ifindex))
 		return -EINVAL;
 
 	lock_sock(sk);
diff --git a/net/can/j1939/Kconfig b/net/can/j1939/Kconfig
new file mode 100644
index 0000000..74d2a86
--- /dev/null
+++ b/net/can/j1939/Kconfig
@@ -0,0 +1,22 @@
+#
+# SAE J1939 network layer core configuration
+#
+
+config CAN_J1939
+	tristate "SAE J1939"
+	depends on CAN
+	---help---
+	  SAE J1939
+	  Say Y to have in-kernel support for j1939 socket type. This
+	  allows communication according to SAE j1939.
+	  The relevant parts in kernel are
+	  SAE j1939-21 (datalink & transport protocol)
+	  & SAE j1939-81 (network management).
+
+config CAN_J1939_DEBUG
+	bool "debug SAE J1939"
+	depends on CAN_J1939
+	default n
+	---help---
+	  Say Y to add extra debug code (via printk) in the j1939 stack
+
diff --git a/net/can/j1939/Makefile b/net/can/j1939/Makefile
new file mode 100644
index 0000000..b07f21a
--- /dev/null
+++ b/net/can/j1939/Makefile
@@ -0,0 +1,11 @@
+cppflags-$(CONFIG_CAN_J1939_DEBUG) += -DDEBUG
+
+obj-$(CONFIG_CAN_J1939) += can-j1939.o
+
+can-j1939-objs := \
+	address-claim.o \
+	bus.o \
+	main.o \
+	socket.o \
+	transport.o
+
diff --git a/net/can/j1939/address-claim.c b/net/can/j1939/address-claim.c
new file mode 100644
index 0000000..4c16d9a
--- /dev/null
+++ b/net/can/j1939/address-claim.c
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/* J1939 Address Claiming.
+ * Address Claiming in the kernel
+ * - keeps track of the AC states of ECU's,
+ * - resolves NAME<=>SA taking into account the AC states of ECU's.
+ *
+ * All Address Claim msgs (including host-originated msg) are processed
+ * at the receive path (a sent msg is always received again via CAN echo).
+ * As such, the processing of AC msgs is done in the order on which msgs
+ * are sent on the bus.
+ *
+ * This module doesn't send msgs itself (e.g. replies on Address Claims),
+ * this is the responsibility of a user space application or daemon.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/byteorder/generic.h>
+
+#include "j1939-priv.h"
+
+#define CANDATA2NAME(data) le64_to_cpup((uint64_t *)data)
+
+static inline int ac_msg_is_request_for_ac(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	int req_pgn;
+
+	if ((skb->len < 3) || (skcb->pgn != PGN_REQUEST))
+		return 0;
+
+	req_pgn = skb->data[0] | (skb->data[1] << 8) | (skb->data[2] << 16);
+
+	return req_pgn == PGN_ADDRESS_CLAIMED;
+}
+
+static int j1939_verify_outgoing_address_claim(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+
+	if (skb->len != 8) {
+		j1939_notice("tx address claim with dlc %i\n", skb->len);
+		return -EPROTO;
+	}
+
+	if (skcb->srcname != CANDATA2NAME(skb->data)) {
+		j1939_notice("tx address claim with different name\n");
+		return -EPROTO;
+	}
+
+	if (skcb->srcaddr == J1939_NO_ADDR) {
+		j1939_notice("tx address claim with broadcast sa\n");
+		return -EPROTO;
+	}
+
+	/* ac must always be a broadcast */
+	if (skcb->dstname || (skcb->dstaddr != J1939_NO_ADDR)) {
+		j1939_notice("tx address claim with dest, not broadcast\n");
+		return -EPROTO;
+	}
+	return 0;
+}
+
+int j1939_fixup_address_claim(struct sk_buff *skb)
+{
+	int ret, sa;
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+
+	/* network mgmt: address claiming msgs */
+	if (skcb->pgn == PGN_ADDRESS_CLAIMED) {
+		struct j1939_ecu *ecu;
+
+		ret = j1939_verify_outgoing_address_claim(skb);
+		/* return both when failure & when successful */
+		if (ret < 0)
+			return ret;
+		ecu = j1939_ecu_find_by_name(skcb->srcname,
+					     skb->dev->ifindex);
+		if (!ecu)
+			return -ENODEV;
+
+		if (ecu->sa != skcb->srcaddr)
+			/* hold further traffic for ecu, remove from parent */
+			j1939_ecu_remove_sa(ecu);
+		put_j1939_ecu(ecu);
+	} else if (skcb->srcname) {
+		/* assign source address */
+		sa = j1939_name_to_sa(skcb->srcname, skb->dev->ifindex);
+		if (!j1939_address_is_unicast(sa) &&
+		    !ac_msg_is_request_for_ac(skb)) {
+			j1939_notice("tx drop: invalid sa for name 0x%016llx\n",
+				     skcb->srcname);
+			return -EADDRNOTAVAIL;
+		}
+		skcb->srcaddr = sa;
+	}
+
+	/* assign destination address */
+	if (skcb->dstname) {
+		sa = j1939_name_to_sa(skcb->dstname, skb->dev->ifindex);
+		if (!j1939_address_is_unicast(sa)) {
+			j1939_notice("tx drop: invalid da for name 0x%016llx\n",
+				     skcb->dstname);
+			return -EADDRNOTAVAIL;
+		}
+		skcb->dstaddr = sa;
+	}
+	return 0;
+}
+
+static void j1939_process_address_claim(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_ecu *ecu, *prev;
+	struct j1939_priv *priv;
+	name_t name;
+
+	if (skb->len != 8) {
+		j1939_notice("rx address claim with wrong dlc %i\n", skb->len);
+		return;
+	}
+
+	name = CANDATA2NAME(skb->data);
+	skcb->srcname = name;
+	if (!name) {
+		j1939_notice("rx address claim without name\n");
+		return;
+	}
+
+	if (!j1939_address_is_valid(skcb->srcaddr)) {
+		j1939_notice("rx address claim with broadcast sa\n");
+		return;
+	}
+
+	priv = j1939_priv_find(skb->skb_iif);
+	if (!priv)
+		return;
+
+	write_lock_bh(&priv->lock);
+
+	ecu = _j1939_ecu_get_register(priv, name,
+				      j1939_address_is_unicast(skcb->srcaddr));
+	if (IS_ERR(ecu))
+		goto done;
+
+	if (skcb->srcaddr >= J1939_IDLE_ADDR) {
+		_j1939_ecu_unregister(ecu);
+		goto done;
+	}
+
+	/* save new SA */
+	if (skcb->srcaddr != ecu->sa)
+		_j1939_ecu_remove_sa(ecu);
+	/* cancel pending (previous) address claim */
+	hrtimer_try_to_cancel(&ecu->ac_timer);
+	ecu->sa = skcb->srcaddr;
+
+	prev = priv->ents[skcb->srcaddr].ecu;
+	if (prev && prev != ecu) {
+		if (ecu->name > prev->name) {
+			_j1939_ecu_unregister(ecu);
+			goto done;
+		} else {
+			/* kick prev */
+			_j1939_ecu_unregister(prev);
+		}
+	}
+
+	/* schedule timer in 250 msec to commit address change */
+	hrtimer_start(&ecu->ac_timer, ktime_set(0, 250000000),
+		      HRTIMER_MODE_REL);
+	/* rxtime administration */
+	ecu->rxtime = ktime_get();
+ done:
+	write_unlock_bh(&priv->lock);
+	put_j1939_priv(priv);
+}
+
+void j1939_recv_address_claim(struct sk_buff *skb, struct j1939_priv *priv)
+{
+	struct j1939_sk_buff_cb *skcb = (void *)skb->cb;
+	struct j1939_ecu *ecu;
+
+	/* network mgmt */
+	if (skcb->pgn == PGN_ADDRESS_CLAIMED) {
+		j1939_process_address_claim(skb);
+	} else if (j1939_address_is_unicast(skcb->srcaddr)) {
+		ecu = j1939_ecu_find_by_addr(skcb->srcaddr, skb->skb_iif);
+		if (ecu) {
+			/* source administration */
+			ecu->rxtime = ktime_get();
+			skcb->srcname = ecu->name;
+			put_j1939_ecu(ecu);
+		}
+	}
+
+	/* assign destination stuff */
+	ecu = j1939_ecu_find_by_addr(skcb->dstaddr, skb->skb_iif);
+	if (ecu) {
+		skcb->dstname = ecu->name;
+		put_j1939_ecu(ecu);
+	}
+}
diff --git a/net/can/j1939/bus.c b/net/can/j1939/bus.c
new file mode 100644
index 0000000..a4d5877
--- /dev/null
+++ b/net/can/j1939/bus.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/* bus for j1939 remote devices
+ * Since rtnetlink, no real bus is used.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/workqueue.h>
+
+#include "j1939-priv.h"
+
+#define ecu_dbg(ecu, fmt, ...) \
+	pr_debug("j1939-%i,%016llx,%02x: " fmt, (ecu)->priv->ifindex, \
+		(ecu)->name, (ecu)->sa, ##__VA_ARGS__)
+#define ecu_alert(ecu, fmt, ...) \
+	pr_alert("j1939-%i,%016llx,%02x: " fmt, (ecu)->priv->ifindex, \
+		(ecu)->name, (ecu)->sa, ##__VA_ARGS__)
+
+/* ECU device interface */
+static enum hrtimer_restart j1939_ecu_timer_handler(struct hrtimer *hrtimer)
+{
+	struct j1939_ecu *ecu =
+		container_of(hrtimer, struct j1939_ecu, ac_timer);
+
+	atomic_set(&ecu->ac_delay_expired, 1);
+	tasklet_schedule(&ecu->priv->ac_task);
+	return HRTIMER_NORESTART;
+}
+
+static void cb_put_j1939_ecu(struct kref *kref)
+{
+	struct j1939_ecu *ecu = container_of(kref, struct j1939_ecu, kref);
+
+	kfree(ecu);
+}
+
+void put_j1939_ecu(struct j1939_ecu *ecu)
+{
+	kref_put(&ecu->kref, cb_put_j1939_ecu);
+}
+
+struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv, name_t name,
+					  int create_if_necessary)
+{
+	struct j1939_ecu *ecu, *dut;
+
+	/* find existing */
+	/* test for existing name */
+	list_for_each_entry(dut, &priv->ecus, list) {
+		if (dut->name == name)
+			return dut;
+	}
+
+	if (!create_if_necessary) {
+		return ERR_PTR(-ENODEV);
+	}
+	/* alloc */
+	ecu = kzalloc(sizeof(*ecu), gfp_any());
+	if (!ecu)
+		/* should we look for an existing ecu */
+		return ERR_PTR(-ENOMEM);
+	kref_init(&ecu->kref);
+	ecu->sa = J1939_IDLE_ADDR;
+	ecu->name = name;
+
+	hrtimer_init(&ecu->ac_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	ecu->ac_timer.function = j1939_ecu_timer_handler;
+	INIT_LIST_HEAD(&ecu->list);
+
+	/* first add to internal list */
+	/* a ref to priv is held */
+	ecu->priv = priv;
+	list_add_tail(&ecu->list, &priv->ecus);
+
+	ecu_dbg(ecu, "register\n");
+	/* do not put_j1939_priv, a new ECU keeps a refcnt open */
+	return ecu;
+}
+
+void _j1939_ecu_unregister(struct j1939_ecu *ecu)
+{
+	ecu_dbg(ecu, "unregister\n");
+	hrtimer_try_to_cancel(&ecu->ac_timer);
+
+	_j1939_ecu_remove_sa(ecu);
+	list_del_init(&ecu->list);
+	put_j1939_ecu(ecu);
+}
+
+struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_priv *priv;
+
+	if (!j1939_address_is_unicast(sa))
+		return NULL;
+	priv = j1939_priv_find(ifindex);
+	if (!priv)
+		return NULL;
+	read_lock_bh(&priv->lock);
+	ecu = priv->ents[sa].ecu;
+	if (ecu)
+		get_j1939_ecu(ecu);
+	read_unlock_bh(&priv->lock);
+	put_j1939_priv(priv);
+	return ecu;
+}
+
+int j1939_name_to_sa(u64 name, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_priv *priv;
+	int sa;
+
+	if (!name)
+		return J1939_NO_ADDR;
+	priv = j1939_priv_find(ifindex);
+	if (!priv)
+		return J1939_NO_ADDR;
+
+	sa = J1939_IDLE_ADDR;
+	read_lock_bh(&priv->lock);
+	list_for_each_entry(ecu, &priv->ecus, list) {
+		if (ecu->name == name) {
+			if (priv->ents[ecu->sa].ecu == ecu)
+				/* ecu's SA is registered */
+				sa = ecu->sa;
+			break;
+		}
+	}
+	read_unlock_bh(&priv->lock);
+	put_j1939_priv(priv);
+	return sa;
+}
+
+/* ecu lookup helper */
+static struct j1939_ecu *_j1939_ecu_find_by_name(name_t name,
+						 struct j1939_priv *priv)
+{
+	struct j1939_ecu *ecu;
+
+	read_lock_bh(&priv->lock);
+	list_for_each_entry(ecu, &priv->ecus, list) {
+		if (ecu->name == name) {
+			get_j1939_ecu(ecu);
+			goto found_on_intf;
+		}
+	}
+	ecu = NULL;
+ found_on_intf:
+	read_unlock_bh(&priv->lock);
+	return ecu;
+}
+
+/* ecu lookup by name */
+struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex)
+{
+	struct j1939_ecu *ecu;
+	struct j1939_priv *priv;
+
+	if (!name)
+		return NULL;
+	if (!ifindex)
+		return NULL;
+	priv = j1939_priv_find(ifindex);
+	if (!priv)
+		return NULL;
+	ecu = _j1939_ecu_find_by_name(name, priv);
+	put_j1939_priv(priv);
+	return ecu;
+}
+
+/* TX addr/name accounting
+ * Transport protocol needs to know if a SA is local or not
+ * These functions originate from userspace manipulating sockets,
+ * so locking is straigforward
+ */
+void j1939_addr_local_get(struct j1939_priv *priv, int sa)
+{
+	if (!j1939_address_is_unicast(sa))
+		return;
+	write_lock_bh(&priv->lock);
+	++priv->ents[sa].nusers;
+	write_unlock_bh(&priv->lock);
+}
+
+void j1939_addr_local_put(struct j1939_priv *priv, int sa)
+{
+	if (!j1939_address_is_unicast(sa))
+		return;
+	write_lock_bh(&priv->lock);
+	--priv->ents[sa].nusers;
+	write_unlock_bh(&priv->lock);
+}
+
+void j1939_name_local_get(struct j1939_priv *priv, u64 name)
+{
+	struct j1939_ecu *ecu;
+
+	if (!name)
+		return;
+
+	write_lock_bh(&priv->lock);
+	ecu = _j1939_ecu_get_register(priv, name, 1);
+	if (!IS_ERR(ecu)) {
+		get_j1939_ecu(ecu);
+		++ecu->nusers;
+		if (priv->ents[ecu->sa].ecu == ecu)
+			/* ecu's sa is active already */
+			++priv->ents[ecu->sa].nusers;
+	}
+	write_unlock_bh(&priv->lock);
+}
+
+void j1939_name_local_put(struct j1939_priv *priv, u64 name)
+{
+	struct j1939_ecu *ecu;
+
+	if (!name)
+		return;
+
+	write_lock_bh(&priv->lock);
+	ecu = _j1939_ecu_get_register(priv, name, 0);
+	if (!IS_ERR(ecu)) {
+		--ecu->nusers;
+		if (priv->ents[ecu->sa].ecu == ecu)
+			/* ecu's sa is active already */
+			--priv->ents[ecu->sa].nusers;
+		put_j1939_ecu(ecu);
+	}
+	write_unlock_bh(&priv->lock);
+}
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
new file mode 100644
index 0000000..1188589
--- /dev/null
+++ b/net/can/j1939/j1939-priv.h
@@ -0,0 +1,333 @@
+/*
+ * j1939-priv.h
+ *
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _J1939_PRIV_H_
+#define _J1939_PRIV_H_
+
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <net/sock.h>
+
+#include <linux/proc_fs.h>
+#include <linux/module.h>
+#include <linux/can/j1939.h>
+#include <linux/atomic.h>
+#include <linux/interrupt.h>
+#include <linux/if_arp.h>
+
+#include "../af_can.h"
+
+/* TODO: return ENETRESET on busoff. */
+
+#define PGN_REQUEST 0x0ea00
+#define PGN_ADDRESS_CLAIMED 0x0ee00
+#define PGN_MAX 0x3ffff
+
+#define SA_MAX_UNICAST 0xfd
+
+/* j1939 devices */
+struct j1939_ecu {
+	struct list_head list;
+	ktime_t rxtime;
+	name_t name;
+	u8 sa;
+
+	/* atomic flag, set by ac_timer
+	 * cleared/processed by segment's tasklet
+	 * indicates that this ecu successfully claimed @sa as its address
+	 * By communicating this from the ac_timer event to segments tasklet,
+	 * a context locking problem is solved. All other 'ecu readers'
+	 * must only lock with _bh, not with _irq.
+	 */
+	atomic_t ac_delay_expired;
+	struct hrtimer ac_timer;
+	struct kref kref;
+	struct j1939_priv *priv;
+
+	/* count users, to help transport protocol decide for interaction */
+	int nusers;
+};
+
+#define to_j1939_ecu(x) container_of((x), struct j1939_ecu, dev)
+
+struct j1939_priv {
+	struct list_head ecus;
+	/* local list entry in priv
+	 * These allow irq (& softirq) context lookups on j1939 devices
+	 * This approach (separate lists) is done as the other 2 alternatives
+	 * are not easier or even wrong
+	 * 1) using the pure kobject methods involves mutexes, which are not
+	 *    allowed in irq context.
+	 * 2) duplicating data structures would require a lot of synchronization
+	 *    code
+	 * usage:
+	 */
+
+	/* segments need a lock to protect the above list */
+	rwlock_t lock;
+
+	int ifindex;
+	struct net_device *netdev;
+	struct addr_ent {
+		ktime_t rxtime;
+		struct j1939_ecu *ecu;
+		/* count users, to help transport protocol */
+		int nusers;
+	} ents[256];
+
+	/* tasklet to process ecu address claimed events.
+	 * These events raise in hardirq context. Signalling the event
+	 * and scheduling this tasklet successfully moves the
+	 * event to softirq context
+	 */
+	struct tasklet_struct ac_task;
+
+	/* list of 256 ecu ptrs, that cache the claimed addresses.
+	 * also protected by the above lock
+	 * don't use directly, use j1939_ecu_set_address() instead
+	 */
+	struct kref kref;
+
+	/* ref counter that hold the number of active listeners.
+	 * This number itself is protected with a mutex
+	 */
+	int nusers;
+};
+
+#define to_j1939_priv(x) container_of((x), struct j1939_priv, dev)
+
+void put_j1939_ecu(struct j1939_ecu *ecu);
+void put_j1939_priv(struct j1939_priv *segment);
+
+static inline void get_j1939_ecu(struct j1939_ecu *dut)
+{
+	kref_get(&dut->kref);
+}
+
+static inline void get_j1939_priv(struct j1939_priv *dut)
+{
+	kref_get(&dut->kref);
+}
+
+/* keep the cache of what is local */
+void j1939_addr_local_get(struct j1939_priv *priv, int sa);
+void j1939_addr_local_put(struct j1939_priv *priv, int sa);
+void j1939_name_local_get(struct j1939_priv *priv, u64 name);
+void j1939_name_local_put(struct j1939_priv *priv, u64 name);
+
+/* conversion function between (struct sock | struct sk_buff)->sk_priority
+ * from linux and j1939 priority field
+ */
+static inline int j1939_prio(int sk_priority)
+{
+	if (sk_priority < 0)
+		return 6; /* default */
+	else if (sk_priority > 7)
+		return 0;
+	else
+		return 7 - sk_priority;
+}
+
+static inline int j1939_to_sk_priority(int j1939_prio)
+{
+	return 7 - j1939_prio;
+}
+
+static inline int j1939_address_is_valid(u8 sa)
+{
+	return sa != J1939_NO_ADDR;
+}
+
+static inline int j1939_address_is_unicast(u8 sa)
+{
+	return sa <= SA_MAX_UNICAST;
+}
+
+static inline int pgn_is_pdu1(pgn_t pgn)
+{
+	/* ignore dp & res bits for this */
+	return (pgn & 0xff00) < 0xf000;
+}
+
+static inline int pgn_is_valid(pgn_t pgn)
+{
+	return pgn <= PGN_MAX;
+}
+
+/* utility to correctly unregister a SA */
+static inline void _j1939_ecu_remove_sa(struct j1939_ecu *ecu)
+{
+	if (!j1939_address_is_unicast(ecu->sa))
+		return;
+	if (ecu->priv && ecu->priv->ents[ecu->sa].ecu == ecu) {
+		ecu->priv->ents[ecu->sa].ecu = NULL;
+		ecu->priv->ents[ecu->sa].nusers -= ecu->nusers;
+	}
+}
+
+static inline void j1939_ecu_remove_sa(struct j1939_ecu *ecu)
+{
+	if (!j1939_address_is_unicast(ecu->sa))
+		return;
+	write_lock_bh(&ecu->priv->lock);
+	_j1939_ecu_remove_sa(ecu);
+	write_unlock_bh(&ecu->priv->lock);
+}
+
+int j1939_name_to_sa(u64 name, int ifindex);
+struct j1939_ecu *j1939_ecu_find_by_addr(int sa, int ifindex);
+struct j1939_ecu *j1939_ecu_find_by_name(name_t name, int ifindex);
+/* find_by_name, with kref & read_lock taken */
+struct j1939_ecu *j1939_ecu_find_priv_default_tx(int ifindex, name_t *pname,
+						 u8 *paddr);
+
+extern struct proc_dir_entry *j1939_procdir;
+
+/* j1939 printk */
+#define j1939_printk(level, ...) printk(level "J1939 " __VA_ARGS__)
+
+#define j1939_err(...)		j1939_printk(KERN_ERR, __VA_ARGS__)
+#define j1939_warning(...)	j1939_printk(KERN_WARNING, __VA_ARGS__)
+#define j1939_notice(...)	j1939_printk(KERN_NOTICE, __VA_ARGS__)
+#define j1939_info(...)		j1939_printk(KERN_INFO, __VA_ARGS__)
+#ifdef DEBUG
+#define j1939_debug(...)	j1939_printk(KERN_DEBUG, __VA_ARGS__)
+#else
+#define j1939_debug(...)
+#endif
+
+struct sk_buff;
+
+/* control buffer of the sk_buff */
+struct j1939_sk_buff_cb {
+	pgn_t pgn;
+	priority_t priority;
+	u8 srcaddr;
+	u8 dstaddr;
+	name_t srcname;
+	name_t dstname;
+
+	/* Flags for quick lookups during skb processing
+	 * These are set in the receive path only
+	 */
+	int srcflags;
+	int dstflags;
+
+#define BAM_NODELAY 1
+#define ECU_LOCAL 1
+
+	/*   Flags for modifying the transport protocol*/
+	int tpflags;
+
+	/* for tx, MSG_SYN will be used to sync on sockets */
+	int msg_flags;
+
+	/* j1939 clones incoming skb's.
+	 * insock saves the incoming skb->sk
+	 * to determine local generated packets
+	 */
+	struct sock *insock;
+};
+
+#define J1939_MSG_RESERVED MSG_SYN
+#define J1939_MSG_SYNC MSG_SYN
+
+static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
+{
+	return (!skcb->dstname && (skcb->dstaddr == 0xff));
+}
+
+//Check if we want to disable the normal BAM 50 ms delay
+//Return 0 if we want to disable the delay
+//Return 1 if we want to keep the delay
+static inline int j1939cb_use_bamdelay(const struct j1939_sk_buff_cb *skcb)
+{
+	//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+	//printk(KERN_ALERT "DEBUG: skcb->tpflags state: %d\n",skcb->tpflags);
+
+	if(skcb->tpflags & BAM_NODELAY)
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+int j1939_send(struct sk_buff *);
+void j1939_recv(struct sk_buff *);
+
+/* stack entries */
+int j1939_send_transport(struct sk_buff *);
+int j1939_recv_transport(struct sk_buff *);
+int j1939_fixup_address_claim(struct sk_buff *);
+void j1939_recv_address_claim(struct sk_buff *, struct j1939_priv *priv);
+
+/* network management */
+
+/* j1939_ecu_get_register
+ * 'create' & 'register' & 'get' new ecu
+ * when a matching ecu already exists, then that is returned
+ */
+struct j1939_ecu *_j1939_ecu_get_register(struct j1939_priv *priv,
+					  name_t name, int create_if_necessary);
+
+/* unregister must be called with lock held */
+void _j1939_ecu_unregister(struct j1939_ecu *);
+
+int j1939_netdev_start(struct net_device *);
+void j1939_netdev_stop(struct net_device *);
+
+static inline struct j1939_priv *dev_j1939_priv(struct net_device *dev)
+{
+	struct dev_rcv_lists *can_ml_priv;
+	struct j1939_priv *priv;
+
+	if (dev->type != ARPHRD_CAN)
+		return NULL;
+
+	can_ml_priv = dev->ml_priv;
+	priv = can_ml_priv ? can_ml_priv->j1939_priv : NULL;
+
+	if (priv)
+		get_j1939_priv(priv);
+
+	return priv;
+}
+
+static inline struct j1939_priv *j1939_priv_find(int ifindex)
+{
+	struct j1939_priv *priv;
+	struct net_device *netdev;
+
+	netdev = dev_get_by_index(&init_net, ifindex);
+	priv = dev_j1939_priv(netdev);
+
+	if (netdev)
+		dev_put(netdev);
+
+	return priv;
+}
+
+/* notify/alert all j1939 sockets bound to ifindex */
+void j1939sk_netdev_event(int ifindex, int error_code);
+int j1939tp_rmdev_notifier(struct net_device *netdev);
+
+/* decrement pending skb for a j1939 socket */
+void j1939_sock_pending_del(struct sock *sk);
+
+/* separate module-init/modules-exit's */
+__init int j1939tp_module_init(void);
+
+void j1939tp_module_exit(void);
+
+/* CAN protocol */
+extern const struct can_proto j1939_can_proto;
+
+#endif /* _J1939_PRIV_H_ */
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
new file mode 100644
index 0000000..3f4b018
--- /dev/null
+++ b/net/can/j1939/main.c
@@ -0,0 +1,474 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+/* Core of can-j1939 that links j1939 to CAN. */
+
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/socket.h>
+#include <linux/list.h>
+#include <linux/if_arp.h>
+#include <net/tcp_states.h>
+
+#include <linux/can.h>
+#include <linux/can/core.h>
+#include "j1939-priv.h"
+
+MODULE_DESCRIPTION("PF_CAN SAE J1939");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("EIA Electronics (Kurt Van Dijck & Pieter Beyens)");
+MODULE_ALIAS("can-proto-" __stringify(CAN_J1939));
+
+static const char j1939_procname[] = "can-j1939";
+struct proc_dir_entry *j1939_procdir;
+
+/* LOWLEVEL CAN interface */
+
+/* CAN_HDR: #bytes before can_frame data part */
+#define CAN_HDR (offsetof(struct can_frame, data))
+
+/* CAN_FTR: #bytes beyond data part */
+#define CAN_FTR (sizeof(struct can_frame) - CAN_HDR - \
+		 sizeof(((struct can_frame *)0)->data))
+
+/* lowest layer */
+static void j1939_can_recv(struct sk_buff *iskb, void *data)
+{
+	struct j1939_priv *priv = data;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skcb;
+	struct can_frame *cf;
+	struct addr_ent *paddr;
+
+	BUILD_BUG_ON(sizeof(*skcb) > sizeof(skb->cb));
+
+	/* create a copy of the skb
+	 * j1939 only delivers the real data bytes,
+	 * the header goes into sockaddr.
+	 * j1939 may not touch the incoming skb in such way
+	 */
+	skb = skb_clone(iskb, GFP_ATOMIC);
+
+	/* get a pointer to the header of the skb
+	 * the skb payload (pointer) is moved, so that the next skb_data
+	 * returns the actual payload
+	 */
+	cf = (void *)skb->data;
+	skb_pull(skb, CAN_HDR);
+
+	/* fix length, set to dlc, with 8 maximum */
+	skb_trim(skb, min_t(uint8_t, cf->can_dlc, 8));
+
+	/* set addr */
+	skcb = (struct j1939_sk_buff_cb *)skb->cb;
+	memset(skcb, 0, sizeof(*skcb));
+
+	/* save incoming socket, without assigning the skb to it */
+	skcb->insock = iskb->sk;
+	skcb->priority = (cf->can_id & 0x1c000000) >> 26;
+	skcb->srcaddr = cf->can_id;
+	skcb->pgn = (cf->can_id & 0x3ffff00) >> 8;
+	if (pgn_is_pdu1(skcb->pgn)) {
+		/* Type 1: with destination address */
+		skcb->dstaddr = skcb->pgn;
+		/* normalize pgn: strip dst address */
+		skcb->pgn &= 0x3ff00;
+	} else {
+		/* set broadcast address */
+		skcb->dstaddr = J1939_NO_ADDR;
+	}
+
+	/* update local rxtime cache */
+	write_lock_bh(&priv->lock);
+	if (j1939_address_is_unicast(skcb->srcaddr)) {
+		paddr = &priv->ents[skcb->srcaddr];
+		paddr->rxtime = ktime_get();
+		if (paddr->ecu && skcb->pgn != 0x0ee00)
+			paddr->ecu->rxtime = paddr->rxtime;
+	}
+	write_unlock_bh(&priv->lock);
+
+	/* update localflags */
+	read_lock_bh(&priv->lock);
+	if (j1939_address_is_unicast(skcb->srcaddr) &&
+	    priv->ents[skcb->srcaddr].nusers)
+		skcb->srcflags |= ECU_LOCAL;
+	if (j1939_address_is_valid(skcb->dstaddr) ||
+	    (j1939_address_is_unicast(skcb->dstaddr) &&
+	     priv->ents[skcb->dstaddr].nusers))
+		skcb->dstflags |= ECU_LOCAL;
+	read_unlock_bh(&priv->lock);
+
+	/* deliver into the j1939 stack ... */
+	j1939_recv_address_claim(skb, priv);
+
+	if (j1939_recv_transport(skb))
+		/* this means the transport layer processed the message */
+		goto done;
+	j1939_recv(skb);
+ done:
+	kfree_skb(skb);
+}
+
+int j1939_send(struct sk_buff *skb)
+{
+	int ret, dlc;
+	canid_t canid;
+	struct j1939_sk_buff_cb *skcb = (struct j1939_sk_buff_cb *)skb->cb;
+	struct can_frame *cf;
+
+	if (skb->len > 8)
+		/* re-route via transport protocol */
+		return j1939_send_transport(skb);
+
+	/* apply sanity checks */
+	skcb->pgn &= (pgn_is_pdu1(skcb->pgn)) ? 0x3ff00 : 0x3ffff;
+	if (skcb->priority > 7)
+		skcb->priority = 6;
+
+	ret = j1939_fixup_address_claim(skb);
+	if (unlikely(ret))
+		goto failed;
+	dlc = skb->len;
+	if (dlc > 8) {
+		ret = -EMSGSIZE;
+		goto failed;
+	}
+
+	/* re-claim the CAN_HDR from the SKB */
+	cf = (void *)skb_push(skb, CAN_HDR);
+
+	/* make it a full can frame again */
+	skb_put(skb, CAN_FTR + (8 - dlc));
+
+	canid = CAN_EFF_FLAG |
+		(skcb->srcaddr) |
+		((skcb->priority & 0x7) << 26);
+	if (pgn_is_pdu1(skcb->pgn))
+		canid |= ((skcb->pgn & 0x3ff00) << 8) |
+			(skcb->dstaddr << 8);
+	else
+		canid |= ((skcb->pgn & 0x3ffff) << 8);
+
+	cf->can_id = canid;
+	cf->can_dlc = dlc;
+
+	return can_send(skb, 1);
+ failed:
+	consume_skb(skb);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(j1939_send);
+
+/* iterate over ECUs,
+ * and register flagged ECUs on their claimed SA
+ */
+static void j1939_priv_ac_task(unsigned long val)
+{
+	struct j1939_priv *priv = (void *)val;
+	struct j1939_ecu *ecu;
+
+	write_lock_bh(&priv->lock);
+	list_for_each_entry(ecu, &priv->ecus, list) {
+		/* next 2 (read & set) could be merged into xxx? */
+		if (!atomic_read(&ecu->ac_delay_expired))
+			continue;
+
+		atomic_set(&ecu->ac_delay_expired, 0);
+		if (j1939_address_is_unicast(ecu->sa)) {
+			ecu->priv->ents[ecu->sa].ecu = ecu;
+			ecu->priv->ents[ecu->sa].nusers += ecu->nusers;
+		}
+	}
+	write_unlock_bh(&priv->lock);
+}
+
+/* NETDEV MANAGEMENT */
+
+/* values for can_rx_(un)register */
+#define J1939_CAN_ID CAN_EFF_FLAG
+#define J1939_CAN_MASK (CAN_EFF_FLAG | CAN_RTR_FLAG)
+
+static DEFINE_MUTEX(j1939_netdev_lock);
+
+int j1939_netdev_start(struct net_device *netdev)
+{
+	int ret;
+	struct j1939_priv *priv;
+	struct dev_rcv_lists *can_ml_priv;
+
+	if (netdev->type != ARPHRD_CAN)
+		return -EAFNOSUPPORT;
+
+	mutex_lock(&j1939_netdev_lock);
+	can_ml_priv = netdev->ml_priv;
+	priv = can_ml_priv->j1939_priv;
+	if (priv) {
+		++priv->nusers;
+		goto done;
+	}
+
+	/* create/stuff j1939_priv */
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto fail_mem;
+	}
+	tasklet_init(&priv->ac_task, j1939_priv_ac_task, (unsigned long)priv);
+	rwlock_init(&priv->lock);
+	INIT_LIST_HEAD(&priv->ecus);
+	priv->netdev = netdev;
+	priv->ifindex = netdev->ifindex;
+	kref_init(&priv->kref);
+	priv->nusers = 1;
+
+	/* add CAN handler */
+	ret = can_rx_register(netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			      j1939_can_recv, priv, "j1939", NULL);
+	if (ret < 0)
+		goto fail_can;
+
+	can_ml_priv->j1939_priv = priv;
+	dev_hold(netdev);
+ done:
+	mutex_unlock(&j1939_netdev_lock);
+	return 0;
+
+ fail_can:
+	kfree(priv);
+ fail_mem:
+	mutex_unlock(&j1939_netdev_lock);
+	return ret;
+}
+
+void j1939_netdev_stop(struct net_device *netdev)
+{
+	struct dev_rcv_lists *can_ml_priv;
+	struct j1939_priv *priv;
+
+	if (netdev->type != ARPHRD_CAN)
+		return;
+	can_ml_priv = netdev->ml_priv;
+
+	mutex_lock(&j1939_netdev_lock);
+	priv = can_ml_priv->j1939_priv;
+	--priv->nusers;
+	if (priv->nusers) {
+		mutex_unlock(&j1939_netdev_lock);
+		return;
+	}
+	/* no users left, start breakdown */
+
+	/* unlink from netdev */
+	can_ml_priv->j1939_priv = NULL;
+	mutex_unlock(&j1939_netdev_lock);
+
+	can_rx_unregister(netdev, J1939_CAN_ID, J1939_CAN_MASK,
+			  j1939_can_recv, priv);
+
+	/* remove pending transport protocol sessions */
+	j1939tp_rmdev_notifier(netdev);
+
+	/* final put */
+	put_j1939_priv(priv);
+	dev_put(netdev);
+}
+
+/* device interface */
+static void on_put_j1939_priv(struct kref *kref)
+{
+	struct j1939_priv *priv = container_of(kref, struct j1939_priv, kref);
+	struct j1939_ecu *ecu;
+
+	tasklet_disable_nosync(&priv->ac_task);
+
+	/* cleanup priv */
+	write_lock_bh(&priv->lock);
+	while (!list_empty(&priv->ecus)) {
+		ecu = list_first_entry(&priv->ecus, struct j1939_ecu, list);
+		_j1939_ecu_unregister(ecu);
+	}
+	write_unlock_bh(&priv->lock);
+	kfree(priv);
+}
+
+void put_j1939_priv(struct j1939_priv *segment)
+{
+	kref_put(&segment->kref, on_put_j1939_priv);
+}
+
+static int j1939_netdev_notify(struct notifier_block *nb,
+			       unsigned long msg, void *data)
+{
+	struct net_device *netdev = (struct net_device *)data;
+
+	if (!net_eq(dev_net(netdev), &init_net))
+		return NOTIFY_DONE;
+
+	if (netdev->type != ARPHRD_CAN)
+		return NOTIFY_DONE;
+
+	switch (msg) {
+	case NETDEV_UNREGISTER:
+		j1939tp_rmdev_notifier(netdev);
+		j1939sk_netdev_event(netdev->ifindex, ENODEV);
+		break;
+
+	case NETDEV_DOWN:
+		j1939sk_netdev_event(netdev->ifindex, ENETDOWN);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block j1939_netdev_notifier = {
+	.notifier_call = j1939_netdev_notify,
+};
+
+/* proc access to the addr+name database */
+static int j1939_proc_show_addr(struct seq_file *sqf, void *v)
+{
+	struct net_device *netdev;
+	struct j1939_priv *priv;
+	int j;
+
+	seq_puts(sqf, "iface\tsa\t#users\n");
+	rcu_read_lock();
+	for_each_netdev_rcu(&init_net, netdev) {
+		priv = dev_j1939_priv(netdev);
+		if (!priv)
+			continue;
+		read_lock_bh(&priv->lock);
+		for (j = 0; j < 0xfe; ++j) {
+			if (!priv->ents[j].nusers)
+				continue;
+			seq_printf(sqf, "%s\t%02x\t%i\n",
+				   netdev->name, j, priv->ents[j].nusers);
+		}
+		read_unlock_bh(&priv->lock);
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+static int j1939_proc_show_name(struct seq_file *sqf, void *v)
+{
+	struct net_device *netdev;
+	struct j1939_priv *priv;
+	struct j1939_ecu *ecu;
+
+	seq_puts(sqf, "iface\tname\tsa\t#users\n");
+	rcu_read_lock();
+	for_each_netdev_rcu(&init_net, netdev) {
+		priv = dev_j1939_priv(netdev);
+		if (!priv)
+			continue;
+		read_lock_bh(&priv->lock);
+		list_for_each_entry(ecu, &priv->ecus, list)
+			seq_printf(sqf, "%s\t%016llx\t%02x%s\t%i\n",
+				   netdev->name, ecu->name, ecu->sa,
+				   (priv->ents[ecu->sa].ecu == ecu) ? "" : "?",
+				   ecu->nusers);
+		read_unlock_bh(&priv->lock);
+	}
+	rcu_read_unlock();
+	return 0;
+}
+
+static int j1939_proc_open_addr(struct inode *inode, struct file *file)
+{
+	return single_open(file, j1939_proc_show_addr, NULL);
+}
+
+static int j1939_proc_open_name(struct inode *inode, struct file *file)
+{
+	return single_open(file, j1939_proc_show_name, NULL);
+}
+
+static const struct file_operations j1939_proc_ops_addr = {
+	.owner		= THIS_MODULE,
+	.open		= j1939_proc_open_addr,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const struct file_operations j1939_proc_ops_name = {
+	.owner		= THIS_MODULE,
+	.open		= j1939_proc_open_name,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* MODULE interface */
+static __init int j1939_module_init(void)
+{
+	int ret;
+
+	pr_info("can: SAE J1939\n");
+
+	/* create /proc/net/can directory */
+	j1939_procdir = proc_mkdir(j1939_procname, init_net.proc_net);
+	if (!j1939_procdir)
+		return -EINVAL;
+
+	register_netdevice_notifier(&j1939_netdev_notifier);
+
+	ret = can_proto_register(&j1939_can_proto);
+	if (ret < 0) {
+		pr_err("can: registration of j1939 protocol failed\n");
+		goto fail_sk;
+	}
+	ret = j1939tp_module_init();
+	if (ret < 0)
+		goto fail_tp;
+
+	if (!proc_create("addr", 0444, j1939_procdir, &j1939_proc_ops_addr))
+		goto fail_addr;
+	if (!proc_create("name", 0444, j1939_procdir, &j1939_proc_ops_name))
+		goto fail_name;
+	return 0;
+
+	remove_proc_entry("name", j1939_procdir);
+ fail_name:
+	remove_proc_entry("addr", j1939_procdir);
+ fail_addr:
+	j1939tp_module_exit();
+ fail_tp:
+	can_proto_unregister(&j1939_can_proto);
+ fail_sk:
+	unregister_netdevice_notifier(&j1939_netdev_notifier);
+	proc_remove(j1939_procdir);
+	j1939_procdir = NULL;
+	return ret;
+}
+
+static __exit void j1939_module_exit(void)
+{
+	remove_proc_entry("name", j1939_procdir);
+	remove_proc_entry("addr", j1939_procdir);
+	j1939tp_module_exit();
+
+	can_proto_unregister(&j1939_can_proto);
+
+	unregister_netdevice_notifier(&j1939_netdev_notifier);
+
+	proc_remove(j1939_procdir);
+	j1939_procdir = NULL;
+}
+
+module_init(j1939_module_init);
+module_exit(j1939_module_exit);
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
new file mode 100644
index 0000000..f2dbc4e
--- /dev/null
+++ b/net/can/j1939/socket.c
@@ -0,0 +1,827 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ * Pieter Beyens <pieter.beyens@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/socket.h>
+#include <linux/list.h>
+#include <linux/if_arp.h>
+#include <net/tcp_states.h>
+
+#include <linux/can/core.h>
+#include <linux/can/skb.h>
+#include <linux/can/j1939.h>
+#include "j1939-priv.h"
+
+#define J1939_MIN_NAMELEN REQUIRED_SIZE(struct sockaddr_can, can_addr.j1939)
+
+/* list of sockets */
+static struct list_head j1939_socks = LIST_HEAD_INIT(j1939_socks);
+static DEFINE_SPINLOCK(j1939_socks_lock);
+
+struct j1939_sock {
+	struct sock sk; /* must be first to skip with memset */
+	struct list_head list;
+
+	int state;
+
+#define JSK_BOUND BIT(0)
+#define JSK_CONNECTED BIT(1)
+#define PROMISC BIT(2)
+#define RECV_OWN BIT(3)
+#define JSK_BAM_DELAY BIT(4)
+
+	int ifindex_started; /* ifindex of netdev */
+
+	struct {
+		name_t src;
+		name_t dst;
+		pgn_t pgn;
+
+		u8 sa, da;
+	} addr;
+
+	struct j1939_filter *filters;
+	int nfilters;
+
+	/* j1939 may emit equal PGN (!= equal CAN-id's) out of order
+	 * when transport protocol comes in.
+	 * To allow emitting in order, keep a 'pending' nr. of packets
+	 */
+	atomic_t skb_pending;
+	wait_queue_head_t waitq;
+};
+
+static inline struct j1939_sock *j1939_sk(const struct sock *sk)
+{
+	return container_of(sk, struct j1939_sock, sk);
+}
+
+/*
+ * j1939_sock_pending_add_first
+ * Succeeds when the first pending SKB is scheduled
+ * Fails when SKB are already pending
+ */
+static inline int j1939_sock_pending_add_first(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	/*
+	 * atomic_cmpxchg returns the old value
+	 * When it was 0, it is exchanged with 1 and this function
+	 * succeeded. (return 1)
+	 * When it was != 0, it is not exchanged, and this fuction
+	 * fails (returns 0).
+	 */
+	return !atomic_cmpxchg(&jsk->skb_pending, 0, 1);
+}
+
+static inline void j1939_sock_pending_add(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	atomic_inc(&jsk->skb_pending);
+}
+
+void j1939_sock_pending_del(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	/* atomic_dec_return returns the new value */
+	if (!atomic_dec_return(&jsk->skb_pending))
+		/* no pending SKB's */
+		wake_up(&jsk->waitq);
+}
+
+static inline int j1939_no_address(const struct sock *sk)
+{
+	const struct j1939_sock *jsk = j1939_sk(sk);
+
+	return (jsk->addr.sa == J1939_NO_ADDR) && !jsk->addr.src;
+}
+
+/* matches skb control buffer (addr) with a j1939 filter */
+static inline int packet_match(const struct j1939_sk_buff_cb *skcb,
+			       const struct j1939_filter *f, int nfilter)
+{
+	if (!nfilter)
+		/* receive all when no filters are assigned */
+		return 1;
+
+	/* Filters relying on the addr for static addressing _should_ get
+	 * packets from dynamic addressed ECU's too if they match their SA.
+	 * Sockets using dynamic addressing in their filters should not set it.
+	 */
+	for (; nfilter; ++f, --nfilter) {
+		if ((skcb->pgn & f->pgn_mask) != (f->pgn & f->pgn_mask))
+			continue;
+		if ((skcb->srcaddr & f->addr_mask) != (f->addr & f->addr_mask))
+			continue;
+		if ((skcb->srcname & f->name_mask) != (f->name & f->name_mask))
+			continue;
+		return 1;
+	}
+	return 0;
+}
+
+/* callback per socket, called from j1939_recv */
+static void j1939sk_recv_skb(struct sk_buff *oskb, struct j1939_sock *jsk)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skcb = (void *)oskb->cb;
+
+	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED)))
+		return;
+	if (jsk->sk.sk_bound_dev_if &&
+	    (jsk->sk.sk_bound_dev_if != oskb->skb_iif))
+		/* this socket does not take packets from this iface */
+		return;
+	if (!(jsk->state & PROMISC)) {
+		if (jsk->addr.src) {
+			/* reject message for other destinations */
+			if (skcb->dstname &&
+			    (skcb->dstname != jsk->addr.src))
+				/* the msg is not destined for the name
+				 * that the socket is bound to
+				 */
+				return;
+		} else {
+			/* reject messages for other destination addresses */
+			if (j1939_address_is_unicast(skcb->dstaddr) &&
+			    (skcb->dstaddr != jsk->addr.sa))
+				/* the msg is not destined for the name
+				 * that the socket is bound to
+				 */
+				return;
+		}
+	}
+
+	if ((skcb->insock == &jsk->sk) && !(jsk->state & RECV_OWN))
+		/* own message */
+		return;
+
+	if (!packet_match(skcb, jsk->filters, jsk->nfilters))
+		return;
+
+	skb = skb_clone(oskb, GFP_ATOMIC);
+	if (!skb) {
+		j1939_warning("skb clone failed\n");
+		return;
+	}
+	skcb = (void *)skb->cb;
+	skcb->msg_flags &= ~(MSG_DONTROUTE | MSG_CONFIRM);
+	if (skcb->insock)
+		skcb->msg_flags |= MSG_DONTROUTE;
+	if (skcb->insock == &jsk->sk)
+		skcb->msg_flags |= MSG_CONFIRM;
+
+	if (sock_queue_rcv_skb(&jsk->sk, skb) < 0)
+		kfree_skb(skb);
+}
+
+void j1939_recv(struct sk_buff *skb)
+{
+	struct j1939_sock *jsk;
+
+	spin_lock_bh(&j1939_socks_lock);
+	list_for_each_entry(jsk, &j1939_socks, list) {
+		j1939sk_recv_skb(skb, jsk);
+	}
+	spin_unlock_bh(&j1939_socks_lock);
+}
+EXPORT_SYMBOL_GPL(j1939_recv);
+
+static int j1939sk_init(struct sock *sk)
+{
+	struct j1939_sock *jsk = j1939_sk(sk);
+
+	INIT_LIST_HEAD(&jsk->list);
+	init_waitqueue_head(&jsk->waitq);
+	jsk->sk.sk_priority = j1939_to_sk_priority(6);
+	jsk->sk.sk_reuse = 1; /* per default */
+	jsk->addr.sa = J1939_NO_ADDR;
+	jsk->addr.da = J1939_NO_ADDR;
+	jsk->addr.pgn = J1939_NO_PGN;
+	atomic_set(&jsk->skb_pending, 0);
+	return 0;
+}
+
+/* helper: return <0 for error, >0 for error to notify */
+static int j1939_ifindex_start(int ifindex)
+{
+	int ret;
+	struct net_device *netdev;
+
+	netdev = dev_get_by_index(&init_net, ifindex);
+	if (!netdev)
+		return -ENODEV;
+
+	/* no need to test for CAN device,
+	 * done by j1939_netdev_start
+	 */
+	ret = j1939_netdev_start(netdev);
+
+	dev_put(netdev);
+	return ret;
+}
+
+static void j1939_ifindex_stop(int ifindex)
+{
+	struct net_device *netdev;
+
+	netdev = dev_get_by_index(&init_net, ifindex);
+	if (netdev) {
+		j1939_netdev_stop(netdev);
+		dev_put(netdev);
+	}
+}
+
+static int j1939sk_bind(struct socket *sock, struct sockaddr *uaddr, int len)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	int ret, bound_dev_if;
+	struct j1939_priv *priv;
+
+	if (len < J1939_MIN_NAMELEN)
+		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
+
+	lock_sock(sock->sk);
+
+	/* bind to device ... */
+	bound_dev_if = jsk->sk.sk_bound_dev_if;
+	/* copy netdev info */
+	if (!bound_dev_if && addr->can_ifindex) {
+		bound_dev_if = addr->can_ifindex;
+	} else if (bound_dev_if && addr->can_ifindex) {
+		/* do netdev */
+		if (bound_dev_if != addr->can_ifindex) {
+			ret = -EBUSY;
+			goto fail_locked;
+		}
+	}
+	/* start j1939 */
+	if (bound_dev_if && bound_dev_if != jsk->ifindex_started) {
+		if (jsk->ifindex_started) {
+			ret = -EBUSY;
+			goto fail_locked;
+		}
+		ret = j1939_ifindex_start(bound_dev_if);
+		if (ret < 0)
+			goto fail_locked;
+		jsk->ifindex_started = bound_dev_if;
+		priv = j1939_priv_find(jsk->ifindex_started);
+		j1939_name_local_get(priv, jsk->addr.src);
+		j1939_addr_local_get(priv, jsk->addr.sa);
+		put_j1939_priv(priv);
+	}
+
+	jsk->sk.sk_bound_dev_if = bound_dev_if;
+
+	/* set addr + name */
+	if (jsk->ifindex_started) {
+		priv = j1939_priv_find(jsk->ifindex_started);
+		/* priv should be set when ifindex_started is nonzero */
+		j1939_name_local_put(priv, jsk->addr.src);
+		j1939_name_local_get(priv, addr->can_addr.j1939.name);
+		j1939_addr_local_put(priv, jsk->addr.sa);
+		j1939_addr_local_get(priv, addr->can_addr.j1939.addr);
+		put_j1939_priv(priv);
+	}
+	jsk->addr.src = addr->can_addr.j1939.name;
+	jsk->addr.sa = addr->can_addr.j1939.addr;
+
+	/* set default transmit pgn */
+	if (pgn_is_valid(addr->can_addr.j1939.pgn))
+		jsk->addr.pgn = addr->can_addr.j1939.pgn;
+
+	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED))) {
+		spin_lock_bh(&j1939_socks_lock);
+		list_add_tail(&jsk->list, &j1939_socks);
+		spin_unlock_bh(&j1939_socks_lock);
+	}
+	jsk->state |= JSK_BOUND;
+
+	ret = 0;
+
+ fail_locked:
+	if (!jsk->sk.sk_bound_dev_if && jsk->ifindex_started) {
+		/* started j1939 on this netdev during this call,
+		 * so we revert that
+		 */
+		j1939_ifindex_stop(jsk->ifindex_started);
+		jsk->ifindex_started = 0;
+	}
+	release_sock(sock->sk);
+	return ret;
+}
+
+static int j1939sk_connect(struct socket *sock, struct sockaddr *uaddr,
+			   int len, int flags)
+{
+	int ret;
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct j1939_sock *jsk = j1939_sk(sock->sk);
+	struct j1939_priv *priv;
+	int bound_dev_if;
+
+	if (!uaddr)
+		return -EDESTADDRREQ;
+
+	if (len < J1939_MIN_NAMELEN)
+		return -EINVAL;
+	if (addr->can_family != AF_CAN)
+		return -EINVAL;
+
+	lock_sock(sock->sk);
+
+	/* bind to device ... */
+	bound_dev_if = jsk->sk.sk_bound_dev_if;
+
+	/* copy netdev info */
+	if (!bound_dev_if && addr->can_ifindex) {
+		bound_dev_if = addr->can_ifindex;
+	} else if (bound_dev_if && addr->can_ifindex) {
+		/* do netdev */
+		if (bound_dev_if != addr->can_ifindex) {
+			ret = -EBUSY;
+			goto fail_locked;
+		}
+	}
+
+	/* start j1939 */
+	if (bound_dev_if && bound_dev_if != jsk->ifindex_started) {
+		if (jsk->ifindex_started) {
+			ret = -EBUSY;
+			goto fail_locked;
+		}
+		ret = j1939_ifindex_start(bound_dev_if);
+		if (ret < 0)
+			goto fail_locked;
+		jsk->ifindex_started = bound_dev_if;
+		/* make sure that this is in sync */
+		priv = j1939_priv_find(jsk->ifindex_started);
+		j1939_name_local_get(priv, jsk->addr.src);
+		j1939_addr_local_get(priv, jsk->addr.sa);
+		put_j1939_priv(priv);
+	}
+
+	/* lookup destination */
+	jsk->addr.dst = addr->can_addr.j1939.name;
+	jsk->addr.da = addr->can_addr.j1939.addr;
+
+	/* start assigning, no problem can occur at this point anymore */
+	jsk->sk.sk_bound_dev_if = bound_dev_if;
+
+	if (pgn_is_valid(addr->can_addr.j1939.pgn))
+		jsk->addr.pgn = addr->can_addr.j1939.pgn;
+
+	if (!(jsk->state & (JSK_BOUND | JSK_CONNECTED))) {
+		spin_lock_bh(&j1939_socks_lock);
+		list_add_tail(&jsk->list, &j1939_socks);
+		spin_unlock_bh(&j1939_socks_lock);
+	}
+	jsk->state |= JSK_CONNECTED;
+	ret = 0;
+
+ fail_locked:
+	release_sock(sock->sk);
+	return ret;
+}
+
+static void j1939sk_sock2sockaddr_can(struct sockaddr_can *addr,
+				      const struct j1939_sock *jsk, int peer)
+{
+	addr->can_family = AF_CAN;
+	addr->can_ifindex = jsk->sk.sk_bound_dev_if;
+	addr->can_addr.j1939.name = peer ? jsk->addr.dst : jsk->addr.src;
+	addr->can_addr.j1939.pgn = jsk->addr.pgn;
+	addr->can_addr.j1939.addr = peer ? jsk->addr.da : jsk->addr.sa;
+}
+
+static int j1939sk_getname(struct socket *sock, struct sockaddr *uaddr,
+			   int *len, int peer)
+{
+	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret = 0;
+
+	lock_sock(sk);
+
+	if (peer && !(jsk->state & JSK_CONNECTED)) {
+		ret = -EADDRNOTAVAIL;
+		goto failure;
+	}
+
+	j1939sk_sock2sockaddr_can(addr, jsk, peer);
+	*len = J1939_MIN_NAMELEN;
+
+ failure:
+	release_sock(sk);
+
+	return ret;
+}
+
+static int j1939sk_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk;
+	struct j1939_priv *priv;
+
+	if (!sk)
+		return 0;
+	lock_sock(sk);
+	jsk = j1939_sk(sk);
+	spin_lock_bh(&j1939_socks_lock);
+	list_del_init(&jsk->list);
+	spin_unlock_bh(&j1939_socks_lock);
+
+	if (jsk->ifindex_started) {
+		priv = j1939_priv_find(jsk->ifindex_started);
+		j1939_addr_local_put(priv, jsk->addr.sa);
+		j1939_name_local_put(priv, jsk->addr.src);
+		put_j1939_priv(priv);
+
+		j1939_ifindex_stop(jsk->ifindex_started);
+	}
+	jsk->ifindex_started = 0;
+
+	sock_orphan(sk);
+	sock->sk = NULL;
+
+	release_sock(sk);
+	sock_put(sk);
+
+	return 0;
+}
+
+static int j1939sk_setsockopt_flag(struct j1939_sock *jsk, char __user *optval,
+				   unsigned int optlen, int flag)
+{
+	int tmp;
+
+	if (optlen != sizeof(tmp))
+		return -EINVAL;
+	if (copy_from_user(&tmp, optval, optlen))
+		return -EFAULT;
+	lock_sock(&jsk->sk);
+	if (tmp)
+		jsk->state |= flag;
+	else
+		jsk->state &= ~flag;
+	release_sock(&jsk->sk);
+	return tmp;
+}
+
+static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
+			      char __user *optval, unsigned int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int tmp, count;
+	struct j1939_filter *filters, *ofilters;
+
+	if (level != SOL_CAN_J1939)
+		return -EINVAL;
+
+	switch (optname) {
+	case SO_J1939_FILTER:
+		if (optval) {
+			if (optlen % sizeof(*filters) != 0)
+				return -EINVAL;
+			count = optlen / sizeof(*filters);
+			filters = kmalloc(optlen, GFP_KERNEL);
+			if (!filters)
+				return -ENOMEM;
+			if (copy_from_user(filters, optval, optlen)) {
+				kfree(filters);
+				return -EFAULT;
+			}
+		} else {
+			filters = NULL;
+			count = 0;
+		}
+
+		spin_lock_bh(&j1939_socks_lock);
+		ofilters = jsk->filters;
+		jsk->filters = filters;
+		jsk->nfilters = count;
+		spin_unlock_bh(&j1939_socks_lock);
+		kfree(ofilters);
+		return 0;
+	case SO_J1939_PROMISC:
+		return j1939sk_setsockopt_flag(jsk, optval, optlen, PROMISC);
+	case SO_J1939_RECV_OWN:
+		return j1939sk_setsockopt_flag(jsk, optval, optlen, RECV_OWN);
+	case SO_J1939_SEND_PRIO:
+		if (optlen != sizeof(tmp))
+			return -EINVAL;
+		if (copy_from_user(&tmp, optval, optlen))
+			return -EFAULT;
+		if ((tmp < 0) || (tmp > 7))
+			return -EDOM;
+		if ((tmp < 2) && !capable(CAP_NET_ADMIN))
+			return -EPERM;
+		lock_sock(&jsk->sk);
+		jsk->sk.sk_priority = j1939_to_sk_priority(tmp);
+		release_sock(&jsk->sk);
+		return 0;
+	case SO_J1939_BAM_DELAY_DISABLE:
+		//Enables/Disables delay
+		tmp = j1939sk_setsockopt_flag(jsk, optval, optlen, JSK_BAM_DELAY);
+		//printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+		//printk("DEBUG: SO_J1939_BAM_DELAY_DISABLE used with value: %d\n",tmp);
+		//printk("DEBUG: jsk->state: %d\n",(int)(jsk->state));
+		return tmp;
+	default:
+		return -ENOPROTOOPT;
+	}
+}
+
+static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
+			      char __user *optval, int __user *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	int ret, ulen;
+	/* set defaults for using 'int' properties */
+	int tmp = 0;
+	int len = sizeof(tmp);
+	void *val = &tmp;
+
+	if (level != SOL_CAN_J1939)
+		return -EINVAL;
+	if (get_user(ulen, optlen))
+		return -EFAULT;
+	if (ulen < 0)
+		return -EINVAL;
+
+	lock_sock(&jsk->sk);
+	switch (optname) {
+	case SO_J1939_PROMISC:
+		tmp = (jsk->state & PROMISC) ? 1 : 0;
+		break;
+	case SO_J1939_RECV_OWN:
+		tmp = (jsk->state & RECV_OWN) ? 1 : 0;
+		break;
+	case SO_J1939_SEND_PRIO:
+		tmp = j1939_prio(jsk->sk.sk_priority);
+		break;
+	case SO_J1939_BAM_DELAY_DISABLE:
+		tmp = (jsk->state & JSK_BAM_DELAY) ? 1 : 0;
+		break;
+	default:
+		ret = -ENOPROTOOPT;
+		goto no_copy;
+	}
+
+	/* copy to user, based on 'len' & 'val'
+	 * but most sockopt's are 'int' properties, and have 'len' & 'val'
+	 * left unchanged, but instead modified 'tmp'
+	 */
+	if (len > ulen)
+		ret = -EFAULT;
+	else if (put_user(len, optlen))
+		ret = -EFAULT;
+	else if (copy_to_user(optval, val, len))
+		ret = -EFAULT;
+	else
+		ret = 0;
+ no_copy:
+	release_sock(&jsk->sk);
+	return ret;
+}
+
+static int j1939sk_recvmsg(struct socket *sock, struct msghdr *msg,
+			   size_t size, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skcb;
+	int ret = 0;
+
+	skb = skb_recv_datagram(sk, flags, 0, &ret);
+	if (!skb)
+		return ret;
+
+	if (size < skb->len)
+		msg->msg_flags |= MSG_TRUNC;
+	else
+		size = skb->len;
+
+	ret = memcpy_to_msg(msg, skb->data, size);
+	if (ret < 0) {
+		skb_free_datagram(sk, skb);
+		return ret;
+	}
+
+	skcb = (void *)skb->cb;
+	if (j1939_address_is_valid(skcb->dstaddr))
+		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_ADDR,
+			 sizeof(skcb->dstaddr), &skcb->dstaddr);
+
+	if (skcb->dstname)
+		put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_DEST_NAME,
+			 sizeof(skcb->dstname), &skcb->dstname);
+
+	put_cmsg(msg, SOL_CAN_J1939, SCM_J1939_PRIO,
+		 sizeof(skcb->priority), &skcb->priority);
+
+	if (msg->msg_name) {
+		struct sockaddr_can *paddr = msg->msg_name;
+
+		msg->msg_namelen = J1939_MIN_NAMELEN;
+		memset(msg->msg_name, 0, msg->msg_namelen);
+		paddr->can_family = AF_CAN;
+		paddr->can_ifindex = skb->skb_iif;
+		paddr->can_addr.j1939.name = skcb->srcname;
+		paddr->can_addr.j1939.addr = skcb->srcaddr;
+		paddr->can_addr.j1939.pgn = skcb->pgn;
+	}
+
+	sock_recv_ts_and_drops(msg, sk, skb);
+	msg->msg_flags |= skcb->msg_flags;
+	skb_free_datagram(sk, skb);
+
+	return size;
+}
+
+static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
+{
+	struct sock *sk = sock->sk;
+	struct j1939_sock *jsk = j1939_sk(sk);
+	struct sockaddr_can *addr = msg->msg_name;
+	struct j1939_sk_buff_cb *skcb;
+	struct sk_buff *skb;
+	struct net_device *dev;
+	int ifindex;
+	int ret;
+
+	/* various socket state tests */
+	if (!(jsk->state & JSK_BOUND))
+		return -EBADFD;
+
+	ifindex = jsk->ifindex_started;
+	if (!ifindex)
+		return -EBADFD;
+
+	if (jsk->addr.sa == J1939_NO_ADDR && !jsk->addr.src)
+		/* no address assigned yet */
+		return -EBADFD;
+
+	/* deal with provided address info */
+	if (msg->msg_name) {
+		if (msg->msg_namelen < J1939_MIN_NAMELEN)
+			return -EINVAL;
+		if (addr->can_family != AF_CAN)
+			return -EINVAL;
+		if (addr->can_ifindex && (ifindex != addr->can_ifindex))
+			return -EBADFD;
+	}
+
+	dev = dev_get_by_index(&init_net, ifindex);
+	if (!dev)
+		return -ENXIO;
+
+	skb = sock_alloc_send_skb(sk,
+				  size +
+				  sizeof(struct can_frame) -
+				  sizeof(((struct can_frame *)NULL)->data) +
+				  sizeof(struct can_skb_priv),
+				  msg->msg_flags & MSG_DONTWAIT, &ret);
+	if (!skb)
+		goto put_dev;
+
+	can_skb_reserve(skb);
+	can_skb_prv(skb)->ifindex = dev->ifindex;
+	skb_reserve(skb, offsetof(struct can_frame, data));
+
+	ret = memcpy_from_msg(skb_put(skb, size), msg, size);
+	if (ret < 0)
+		goto free_skb;
+	sock_tx_timestamp(sk, skb->sk->sk_tsflags, &skb_shinfo(skb)->tx_flags);
+
+	skb->dev = dev;
+
+	skcb = (void *)skb->cb;
+	memset(skcb, 0, sizeof(*skcb));
+	skcb->msg_flags = msg->msg_flags;
+	skcb->srcname = jsk->addr.src;
+	skcb->dstname = jsk->addr.dst;
+	skcb->pgn = jsk->addr.pgn;
+	skcb->priority = j1939_prio(jsk->sk.sk_priority);
+	skcb->srcaddr = jsk->addr.sa;
+	skcb->dstaddr = jsk->addr.da;
+
+	//Check if delay has been disabled
+	skcb->tpflags = (jsk->state & JSK_BAM_DELAY)?BAM_NODELAY:0;
+	//printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+	//printk("DEBUG: skcb->tpflags state: %d\n",skcb->tpflags);
+
+	if (msg->msg_name) {
+		struct sockaddr_can *addr = msg->msg_name;
+
+		if (addr->can_addr.j1939.name ||
+		    (addr->can_addr.j1939.addr != J1939_NO_ADDR)) {
+			skcb->dstname = addr->can_addr.j1939.name;
+			skcb->dstaddr = addr->can_addr.j1939.addr;
+		}
+		if (pgn_is_valid(addr->can_addr.j1939.pgn))
+			skcb->pgn = addr->can_addr.j1939.pgn;
+	}
+	if (!pgn_is_valid(skcb->pgn)) {
+		ret = -EINVAL;
+		goto free_skb;
+	}
+
+	if (skcb->msg_flags & J1939_MSG_SYNC) {
+		if (skcb->msg_flags & MSG_DONTWAIT) {
+			ret = j1939_sock_pending_add_first(&jsk->sk);
+			if (ret > 0)
+				ret = -EAGAIN;
+		} else {
+			ret = wait_event_interruptible(jsk->waitq,
+						       j1939_sock_pending_add_first(&jsk->sk));
+		}
+		if (ret < 0)
+			goto free_skb;
+	} else {
+		j1939_sock_pending_add(&jsk->sk);
+	}
+
+	ret = j1939_send(skb);
+	if (ret < 0)
+		j1939_sock_pending_del(&jsk->sk);
+
+	dev_put(dev);
+	return (ret < 0) ? ret : size;
+
+ free_skb:
+	kfree_skb(skb);
+ put_dev:
+	dev_put(dev);
+	return ret;
+}
+
+void j1939sk_netdev_event(int ifindex, int error_code)
+{
+	struct j1939_sock *jsk;
+
+	spin_lock_bh(&j1939_socks_lock);
+	list_for_each_entry(jsk, &j1939_socks, list) {
+		if (jsk->sk.sk_bound_dev_if != ifindex)
+			continue;
+		jsk->sk.sk_err = error_code;
+		if (!sock_flag(&jsk->sk, SOCK_DEAD))
+			jsk->sk.sk_error_report(&jsk->sk);
+		/* do not remove filters here */
+	}
+	spin_unlock_bh(&j1939_socks_lock);
+}
+
+static const struct proto_ops j1939_ops = {
+	.family = PF_CAN,
+	.release = j1939sk_release,
+	.bind = j1939sk_bind,
+	.connect = j1939sk_connect,
+	.socketpair = sock_no_socketpair,
+	.accept = sock_no_accept,
+	.getname = j1939sk_getname,
+	.poll = datagram_poll,
+	.ioctl = can_ioctl,
+	.listen = sock_no_listen,
+	.shutdown = sock_no_shutdown,
+	.setsockopt = j1939sk_setsockopt,
+	.getsockopt = j1939sk_getsockopt,
+	.sendmsg = j1939sk_sendmsg,
+	.recvmsg = j1939sk_recvmsg,
+	.mmap = sock_no_mmap,
+	.sendpage = sock_no_sendpage,
+};
+
+static struct proto j1939_proto __read_mostly = {
+	.name = "CAN_J1939",
+	.owner = THIS_MODULE,
+	.obj_size = sizeof(struct j1939_sock),
+	.init = j1939sk_init,
+};
+
+const struct can_proto j1939_can_proto = {
+	.type = SOCK_DGRAM,
+	.protocol = CAN_J1939,
+	.ops = &j1939_ops,
+	.prot = &j1939_proto,
+};
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
new file mode 100644
index 0000000..a990c6e
--- /dev/null
+++ b/net/can/j1939/transport.c
@@ -0,0 +1,1538 @@
+/*
+ * Copyright (c) 2010-2011 EIA Electronics
+ *
+ * Authors:
+ * Kurt Van Dijck <kurt.van.dijck@eia.be>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ */
+
+#include <linux/skbuff.h>
+#include <linux/hrtimer.h>
+#include <linux/version.h>
+#include <linux/if_arp.h>
+#include <linux/wait.h>
+#include <linux/seq_file.h>
+#include <linux/can/skb.h>
+#include "j1939-priv.h"
+
+#define REGULAR 0
+#define EXTENDED 1
+
+#define etp_pgn_ctl 0xc800
+#define etp_pgn_dat 0xc700
+#define tp_pgn_ctl 0xec00
+#define tp_pgn_dat 0xeb00
+
+#define tp_cmd_bam 0x20
+#define tp_cmd_rts 0x10
+#define tp_cmd_cts 0x11
+#define tp_cmd_eof 0x13
+#define tp_cmd_abort 0xff
+
+#define etp_cmd_rts 0x14
+#define etp_cmd_cts 0x15
+#define etp_cmd_dpo 0x16
+#define etp_cmd_eof 0x17
+#define etp_cmd_abort 0xff
+
+#define ABORT_BUSY 1
+#define ABORT_RESOURCE 2
+#define ABORT_TIMEOUT 3
+#define ABORT_GENERIC 4
+#define ABORT_FAULT 5
+
+#define MAX_TP_PACKET_SIZE (7 * 0xff)
+#define MAX_ETP_PACKET_SIZE (7 * 0x00ffffff)
+
+static unsigned int block = 255;
+static unsigned int max_packet_size = MAX_ETP_PACKET_SIZE;
+static unsigned int retry_ms = 20;
+static unsigned int packet_delay;
+static unsigned int padding = 1;
+
+/* the limit values for sysctl */
+static int block_min = 1;
+static int block_max = 255;
+static int max_size_min = 8;
+static int max_size_max = MAX_ETP_PACKET_SIZE;
+static int retry_min = 1;
+static int retry_max = 1250;
+static int packet_delay_min = 0;
+static int packet_delay_max = 1250;
+static int padding_min = 0;
+static int padding_max = 1;
+
+struct session {
+	struct list_head list;
+	atomic_t refs;
+	spinlock_t lock;
+
+	/* ifindex, src, dst, pgn define the session block
+	 * the are _never_ modified after insertion in the list
+	 * this decreases locking problems a _lot_
+	 */
+	struct j1939_sk_buff_cb *cb;
+	struct sk_buff *skb;
+	int skb_iif;
+
+	/* all tx related stuff (last_txcmd, pkt.tx)
+	 * is protected (modified only) with the txtask tasklet
+	 * 'total' & 'block' are never changed,
+	 * last_cmd, last & block are protected by ->lock
+	 * this means that the tx may run after cts is received that should
+	 * have stopped tx, but this time discrepancy is never avoided anyhow
+	 */
+	u8 last_cmd, last_txcmd;
+	u8 transmission;
+	u8 extd;
+	struct {
+		/* these do not require 16 bit, they should fit in u8
+		 * but putting in int makes it easier to deal with
+		 */
+		unsigned int total, done, last, tx;
+		unsigned int block; /* for TP */
+		unsigned int dpo; /* for ETP */
+	} pkt;
+	struct hrtimer txtimer, rxtimer;
+
+	/* tasklets for execution of tx/rx timer handler in softirq */
+	struct tasklet_struct txtask, rxtask;
+};
+
+/* forward declarations */
+static struct session *j1939session_new(struct sk_buff *skb);
+static struct session *j1939session_fresh_new(int size,
+					      struct sk_buff *rel_skb,
+					      pgn_t pgn);
+static void j1939tp_del_work(struct work_struct *work);
+
+/* local variables */
+static DEFINE_SPINLOCK(tp_lock);
+static struct list_head tp_sessionq = LIST_HEAD_INIT(tp_sessionq);
+static struct list_head tp_extsessionq = LIST_HEAD_INIT(tp_extsessionq);
+static DEFINE_SPINLOCK(tp_dellock);
+static struct list_head tp_delsessionq = LIST_HEAD_INIT(tp_delsessionq);
+static DECLARE_WORK(tp_delwork, j1939tp_del_work);
+static DECLARE_WAIT_QUEUE_HEAD(tp_wait);
+
+/* helpers */
+static inline void fix_cb(struct j1939_sk_buff_cb *cb)
+{
+	cb->msg_flags &= ~J1939_MSG_RESERVED;
+}
+
+static inline struct list_head *sessionq(int extd)
+{
+	return extd ? &tp_extsessionq : &tp_sessionq;
+}
+
+static inline void j1939session_destroy(struct session *session)
+{
+	if (session->skb)
+		kfree_skb(session->skb);
+	hrtimer_cancel(&session->rxtimer);
+	hrtimer_cancel(&session->txtimer);
+	tasklet_disable(&session->rxtask);
+	tasklet_disable(&session->txtask);
+	kfree(session);
+}
+
+/* clean up work queue */
+static void j1939tp_del_work(struct work_struct *work)
+{
+	struct session *session;
+	int cnt = 0;
+
+	do {
+		session = NULL;
+		spin_lock_bh(&tp_dellock);
+		if (list_empty(&tp_delsessionq)) {
+			spin_unlock_bh(&tp_dellock);
+			break;
+		}
+		session = list_first_entry(&tp_delsessionq,
+					   struct session, list);
+		list_del_init(&session->list);
+		spin_unlock_bh(&tp_dellock);
+		j1939session_destroy(session);
+		++cnt;
+	} while (1);
+}
+
+/* reference counter */
+static inline void get_session(struct session *session)
+{
+	atomic_inc(&session->refs);
+}
+
+static void put_session(struct session *session)
+{
+	if (atomic_add_return(-1, &session->refs) >= 0)
+		/* not the last one */
+		return;
+
+	hrtimer_try_to_cancel(&session->rxtimer);
+	hrtimer_try_to_cancel(&session->txtimer);
+	tasklet_disable_nosync(&session->rxtask);
+	tasklet_disable_nosync(&session->txtask);
+
+	if (in_interrupt()) {
+		spin_lock_bh(&tp_dellock);
+		list_add_tail(&session->list, &tp_delsessionq);
+		spin_unlock_bh(&tp_dellock);
+		schedule_work(&tp_delwork);
+	} else {
+		/* destroy session right here */
+		j1939session_destroy(session);
+	}
+}
+
+/* transport status locking */
+static inline void session_lock(struct session *session)
+{
+	get_session(session); /* safety measure */
+	spin_lock_bh(&session->lock);
+}
+
+static inline void session_unlock(struct session *session)
+{
+	spin_unlock_bh(&session->lock);
+	put_session(session);
+}
+
+static inline void sessionlist_lock(void)
+{
+	spin_lock_bh(&tp_lock);
+}
+
+static inline void sessionlist_unlock(void)
+{
+	spin_unlock_bh(&tp_lock);
+}
+
+/* see if we are receiver
+ * returns 0 for broadcasts, although we will receive them
+ */
+static inline int j1939tp_im_receiver(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	return cb->dstflags & ECU_LOCAL;
+}
+
+/* see if we are sender */
+static inline int j1939tp_im_transmitter(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	return cb->srcflags & ECU_LOCAL;
+}
+
+/* see if we are involved as either receiver or transmitter */
+static int j1939tp_im_involved(struct sk_buff *skb, int swap)
+{
+	return swap ? j1939tp_im_receiver(skb) : j1939tp_im_transmitter(skb);
+}
+
+static int j1939tp_im_involved_anydir(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	return (cb->srcflags | cb->dstflags) & ECU_LOCAL;
+}
+
+/* extract pgn from flow-ctl message */
+static inline pgn_t j1939xtp_ctl_to_pgn(const u8 *dat)
+{
+	pgn_t pgn;
+
+	pgn = (dat[7] << 16) | (dat[6] << 8) | (dat[5] << 0);
+	if (pgn_is_pdu1(pgn))
+		pgn &= 0xffff00;
+	return pgn;
+}
+
+static inline unsigned int j1939tp_ctl_to_size(const u8 *dat)
+{
+	return (dat[2] << 8) + (dat[1] << 0);
+}
+
+static inline unsigned int j1939etp_ctl_to_packet(const u8 *dat)
+{
+	return (dat[4] << 16) | (dat[3] << 8) | (dat[2] << 0);
+}
+
+static inline unsigned int j1939etp_ctl_to_size(const u8 *dat)
+{
+	return (dat[4] << 24) | (dat[3] << 16) |
+		(dat[2] << 8) | (dat[1] << 0);
+}
+
+/* find existing session:
+ * reverse: swap cb's src & dst
+ * there is no problem with matching broadcasts, since
+ * broadcasts (no dst, no da) would never call this
+ * with reverse == 1
+ */
+static int j1939tp_match(struct session *session, struct sk_buff *skb,
+			 int reverse)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	if (session->skb_iif != skb->skb_iif)
+		return 0;
+	if (!reverse) {
+		if (session->cb->srcname) {
+			if (session->cb->srcname != cb->srcname)
+				return 0;
+		} else if (session->cb->srcaddr != cb->srcaddr) {
+			return 0;
+		}
+
+		if (session->cb->dstname) {
+			if (session->cb->dstname != cb->dstname)
+				return 0;
+		} else if (session->cb->dstaddr != cb->dstaddr) {
+			return 0;
+		}
+	} else {
+		if (session->cb->srcname) {
+			if (session->cb->srcname != cb->dstname)
+				return 0;
+		} else if (session->cb->srcaddr != cb->dstaddr) {
+			return 0;
+		}
+
+		if (session->cb->dstname) {
+			if (session->cb->dstname != cb->srcname)
+				return 0;
+		} else if (session->cb->dstaddr != cb->srcaddr) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static struct session *_j1939tp_find(struct list_head *root,
+				     struct sk_buff *skb, int reverse)
+{
+	struct session *session;
+
+	list_for_each_entry(session, root, list) {
+		get_session(session);
+		if (j1939tp_match(session, skb, reverse))
+			return session;
+		put_session(session);
+	}
+
+	return NULL;
+}
+
+static struct session *j1939tp_find(struct list_head *root,
+				    struct sk_buff *skb, int reverse)
+{
+	struct session *session;
+
+	sessionlist_lock();
+	session = _j1939tp_find(root, skb, reverse);
+	sessionlist_unlock();
+
+	return session;
+}
+
+static void j1939_skbcb_swap(struct j1939_sk_buff_cb *cb)
+{
+	name_t name;
+	u8 addr;
+	int flags;
+
+	name = cb->dstname;
+	cb->dstname = cb->srcname;
+	cb->srcname = name;
+
+	addr = cb->dstaddr;
+	cb->dstaddr = cb->srcaddr;
+	cb->srcaddr = addr;
+
+	flags = cb->dstflags;
+	cb->dstflags = cb->srcflags;
+	cb->srcflags = flags;
+}
+
+/* TP transmit packet functions */
+static int j1939tp_tx_dat(struct sk_buff *related, int extd,
+			  const u8 *dat, int len)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skb_cb;
+	u8 *skdat;
+
+	skb = alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv),
+			GFP_ATOMIC);
+	if (unlikely(!skb)) {
+		pr_alert("%s: out of memory?\n", __func__);
+		return -ENOMEM;
+	}
+	can_skb_reserve(skb);
+	can_skb_prv(skb)->ifindex = can_skb_prv(related)->ifindex;
+	/* reserve CAN header */
+	skb_reserve(skb, offsetof(struct can_frame, data));
+
+	skb->dev = related->dev;
+	skb->protocol = related->protocol;
+	skb->pkt_type = related->pkt_type;
+	skb->ip_summed = related->ip_summed;
+
+	memcpy(skb->cb, related->cb, sizeof(skb->cb));
+	skb_cb = (void *)skb->cb;
+	fix_cb(skb_cb);
+	/* fix pgn */
+	skb_cb->pgn = extd ? etp_pgn_dat : tp_pgn_dat;
+
+	skdat = skb_put(skb, len);
+	memcpy(skdat, dat, len);
+	if (padding && len < 8)
+		memset(skb_put(skb, 8 - len), 0xff, 8 - len);
+	return j1939_send(skb);
+}
+
+static int j1939xtp_do_tx_ctl(struct sk_buff *related, int extd,
+			      int swap_src_dst, pgn_t pgn, const u8 *dat)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *skb_cb;
+	u8 *skdat;
+
+	if (!j1939tp_im_involved(related, swap_src_dst))
+		return 0;
+
+	skb = alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv),
+			GFP_ATOMIC);
+	if (unlikely(!skb)) {
+		pr_alert("%s: out of memory?\n", __func__);
+		return -ENOMEM;
+	}
+	skb->dev = related->dev;
+	can_skb_reserve(skb);
+	can_skb_prv(skb)->ifindex = can_skb_prv(related)->ifindex;
+	/* reserve CAN header */
+	skb_reserve(skb, offsetof(struct can_frame, data));
+	skb->protocol = related->protocol;
+	skb->pkt_type = related->pkt_type;
+	skb->ip_summed = related->ip_summed;
+
+	memcpy(skb->cb, related->cb, sizeof(skb->cb));
+	skb_cb = (void *)skb->cb;
+	fix_cb(skb_cb);
+	if (swap_src_dst)
+		j1939_skbcb_swap(skb_cb);
+	skb_cb->pgn = extd ? etp_pgn_ctl : tp_pgn_ctl;
+
+	skdat = skb_put(skb, 8);
+	memcpy(skdat, dat, 5);
+	skdat[5] = (pgn >> 0);
+	skdat[6] = (pgn >> 8);
+	skdat[7] = (pgn >> 16);
+
+	return j1939_send(skb);
+}
+
+static inline int j1939tp_tx_ctl(struct session *session,
+				 int swap_src_dst, const u8 *dat)
+{
+	return j1939xtp_do_tx_ctl(session->skb, session->extd, swap_src_dst,
+				  session->cb->pgn, dat);
+}
+
+static int j1939xtp_tx_abort(struct sk_buff *related, int extd,
+			     int swap_src_dst, int err, pgn_t pgn)
+{
+	u8 dat[5];
+
+	if (!j1939tp_im_involved(related, swap_src_dst))
+		return 0;
+
+	memset(dat, 0xff, sizeof(dat));
+	dat[0] = tp_cmd_abort;
+	if (!extd)
+		dat[1] = err ?: ABORT_GENERIC;
+	return j1939xtp_do_tx_ctl(related, extd, swap_src_dst, pgn, dat);
+}
+
+/* timer & scheduler functions */
+static inline void j1939session_schedule_txnow(struct session *session)
+{
+	tasklet_schedule(&session->txtask);
+}
+
+static enum hrtimer_restart j1939tp_txtimer(struct hrtimer *hrtimer)
+{
+	struct session *session;
+
+	session = container_of(hrtimer, struct session, txtimer);
+	j1939session_schedule_txnow(session);
+
+	return HRTIMER_NORESTART;
+}
+
+static inline void j1939tp_schedule_txtimer(struct session *session, int msec)
+{
+	hrtimer_start(&session->txtimer,
+		      ktime_set(msec / 1000, (msec % 1000) * 1000000UL),
+		      HRTIMER_MODE_REL);
+}
+
+static inline void j1939tp_set_rxtimeout(struct session *session, int msec)
+{
+	hrtimer_start(&session->rxtimer,
+		      ktime_set(msec / 1000, (msec % 1000) * 1000000UL),
+		      HRTIMER_MODE_REL);
+}
+
+/* session completion functions */
+
+/* j1939session_drop
+ * removes a session from open session list
+ */
+static inline void j1939session_drop(struct session *session)
+{
+	sessionlist_lock();
+	list_del_init(&session->list);
+	sessionlist_unlock();
+
+	if (session->transmission) {
+		if (session->skb && session->skb->sk)
+			j1939_sock_pending_del(session->skb->sk);
+		wake_up_all(&tp_wait);
+	}
+	put_session(session);
+}
+
+static inline void j1939session_completed(struct session *session)
+{
+	/* distribute among j1939 receivers */
+	j1939_recv(session->skb);
+	j1939session_drop(session);
+}
+
+static void j1939session_cancel(struct session *session, int err)
+{
+	if ((err >= 0) && j1939tp_im_involved_anydir(session->skb)) {
+		if (!j1939cb_is_broadcast(session->cb)) {
+			/* do not send aborts on incoming broadcasts */
+			j1939xtp_tx_abort(session->skb, session->extd,
+					  !(session->cb->srcflags & ECU_LOCAL),
+					  err, session->cb->pgn);
+		}
+	}
+	j1939session_drop(session);
+}
+
+static enum hrtimer_restart j1939tp_rxtimer(struct hrtimer *hrtimer)
+{
+	struct session *session = container_of(hrtimer, struct session,
+					       rxtimer);
+
+	tasklet_schedule(&session->rxtask);
+	return HRTIMER_NORESTART;
+}
+
+static void j1939tp_rxtask(unsigned long val)
+{
+	struct session *session = (void *)val;
+
+	get_session(session);
+	pr_alert("%s: timeout on %i\n", __func__, session->skb_iif);
+	j1939session_cancel(session, ABORT_TIMEOUT);
+	put_session(session);
+}
+
+/* receive packet functions */
+static void _j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (session /*&& (session->cb->pgn == pgn)*/) {
+		/* do not allow TP control messages on 2 pgn's */
+		j1939session_cancel(session, ABORT_FAULT);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	j1939xtp_tx_abort(skb, extd, 0, ABORT_FAULT, pgn);
+	if (!session)
+		return;
+	put_session(session); /* ~j1939tp_find */
+}
+
+/* abort packets may come in 2 directions */
+static void j1939xtp_rx_bad_message(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	pr_info("%s, pgn %05x\n", __func__, j1939xtp_ctl_to_pgn(skb->data));
+
+	_j1939xtp_rx_bad_message(skb, extd);
+	j1939_skbcb_swap(cb);
+	_j1939xtp_rx_bad_message(skb, extd);
+
+	/* restore skb */
+	j1939_skbcb_swap(cb);
+}
+
+static void _j1939xtp_rx_abort(struct sk_buff *skb, int extd, int reverse)
+{
+	struct session *session;
+	pgn_t pgn;
+
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), skb, reverse);
+	if (!session)
+		return;
+	if (session->transmission && !session->last_txcmd) {
+		/* empty block:
+		 * do not drop session when a transmit session did not
+		 * start yet
+		 */
+	} else if (session->cb->pgn == pgn) {
+		j1939session_drop(session);
+	}
+
+	/* TODO: maybe cancel current connection
+	 * as another pgn was communicated
+	 */
+	put_session(session); /* ~j1939tp_find */
+}
+
+/* abort packets may come in 2 directions */
+static inline void j1939xtp_rx_abort(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+
+	pr_info("%s %i, %05x\n", __func__, skb->skb_iif,
+		j1939xtp_ctl_to_pgn(skb->data));
+
+	_j1939xtp_rx_abort(skb, extd, 0);
+	_j1939xtp_rx_abort(skb, extd, 1);
+}
+
+static void j1939xtp_rx_eof(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+
+	/* end of tx cycle */
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), skb, 1);
+	if (!session) {
+		/* strange, we had EOF on closed connection
+		 * do nothing, as EOF closes the connection anyway
+		 */
+		return;
+	}
+
+	if (session->cb->pgn != pgn) {
+		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+	} else {
+		/* transmitted without problems */
+		j1939session_completed(session);
+	}
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_cts(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+	unsigned int pkt;
+	const u8 *dat;
+
+	dat = skb->data;
+	pgn = j1939xtp_ctl_to_pgn(skb->data);
+	session = j1939tp_find(sessionq(extd), skb, 1);
+	if (!session) {
+		/* 'CTS shall be ignored' */
+		return;
+	}
+
+	if (session->cb->pgn != pgn) {
+		/* what to do? */
+		j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+
+	session_lock(session);
+	pkt = extd ? j1939etp_ctl_to_packet(dat) : dat[2];
+	if (!dat[0]) {
+		hrtimer_cancel(&session->txtimer);
+	} else if (!pkt) {
+		goto bad_fmt;
+	} else if (dat[1] > session->pkt.block /* 0xff for etp */) {
+		goto bad_fmt;
+	} else {
+		/* set packet counters only when not CTS(0) */
+		session->pkt.done = pkt - 1;
+		session->pkt.last = session->pkt.done + dat[1];
+		if (session->pkt.last > session->pkt.total)
+			/* safety measure */
+			session->pkt.last = session->pkt.total;
+		/* TODO: do not set tx here, do it in txtask */
+		session->pkt.tx = session->pkt.done;
+	}
+
+	session->last_cmd = dat[0];
+	session_unlock(session);
+	if (dat[1]) {
+		j1939tp_set_rxtimeout(session, 1250);
+		if (j1939tp_im_transmitter(session->skb))
+			j1939session_schedule_txnow(session);
+	} else {
+		/* CTS(0) */
+		j1939tp_set_rxtimeout(session, 550);
+	}
+	put_session(session); /* ~j1939tp_find */
+	return;
+ bad_fmt:
+	session_unlock(session);
+	j1939session_cancel(session, ABORT_FAULT);
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_rts(struct sk_buff *skb, int extd)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	int len;
+	const u8 *dat;
+	pgn_t pgn;
+
+	dat = skb->data;
+	pgn = j1939xtp_ctl_to_pgn(dat);
+
+	if ((tp_cmd_rts == dat[0]) && j1939cb_is_broadcast(cb)) {
+		pr_alert("%s: rts without destination (%i %02x)\n", __func__,
+			 skb->skb_iif, cb->srcaddr);
+		return;
+	}
+
+	/* TODO: abort RTS when a similar
+	 * TP is pending in the other direction
+	 */
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (session && !j1939tp_im_transmitter(skb)) {
+		/* RTS on pending connection */
+		j1939session_cancel(session, ABORT_BUSY);
+		if ((pgn != session->cb->pgn) && (tp_cmd_bam != dat[0]))
+			j1939xtp_tx_abort(skb, extd, 1, ABORT_BUSY, pgn);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	} else if (!session && j1939tp_im_transmitter(skb)) {
+		pr_alert("%s: I should tx (%i %02x %02x)\n", __func__,
+			 skb->skb_iif, cb->srcaddr, cb->dstaddr);
+		return;
+	}
+	if (session && (session->last_cmd != 0)) {
+		/* we received a second rts on the same connection */
+		pr_alert("%s: connection exists (%i %02x %02x)\n", __func__,
+			 skb->skb_iif, cb->srcaddr, cb->dstaddr);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+	if (session) {
+		/* make sure 'sa' & 'da' are correct !
+		 * They may be 'not filled in yet' for sending
+		 * skb's, since they did not pass the Address Claim ever.
+		 */
+		session->cb->srcaddr = cb->srcaddr;
+		session->cb->dstaddr = cb->dstaddr;
+	} else {
+		int abort = 0;
+
+		if (extd) {
+			len = j1939etp_ctl_to_size(dat);
+			if (len > MAX_ETP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+			else if (max_packet_size && (len > max_packet_size))
+				abort = ABORT_RESOURCE;
+			else if (len <= MAX_TP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+		} else {
+			len = j1939tp_ctl_to_size(dat);
+			if (len > MAX_TP_PACKET_SIZE)
+				abort = ABORT_FAULT;
+			else if (max_packet_size && (len > max_packet_size))
+				abort = ABORT_RESOURCE;
+		}
+		if (abort) {
+			j1939xtp_tx_abort(skb, extd, 1, abort, pgn);
+			return;
+		}
+		session = j1939session_fresh_new(len, skb, pgn);
+		if (!session) {
+			j1939xtp_tx_abort(skb, extd, 1, ABORT_RESOURCE, pgn);
+			return;
+		}
+		session->extd = extd;
+
+		/* initialize the control buffer: plain copy */
+		session->pkt.total = (len + 6) / 7;
+		session->pkt.block = 0xff;
+		if (!extd) {
+			if (dat[3] != session->pkt.total)
+				pr_alert("%s: strange total, %u != %u\n",
+					 __func__, session->pkt.total,
+					 dat[3]);
+			session->pkt.total = dat[3];
+			session->pkt.block = dat[4];
+		}
+		session->pkt.done = 0;
+		session->pkt.tx = 0;
+		get_session(session); /* equivalent to j1939tp_find() */
+		sessionlist_lock();
+		list_add_tail(&session->list, sessionq(extd));
+		sessionlist_unlock();
+	}
+	session->last_cmd = dat[0];
+
+	j1939tp_set_rxtimeout(session, 1250);
+
+	if (j1939tp_im_receiver(session->skb)) {
+		if (extd || (tp_cmd_bam != dat[0]))
+			j1939session_schedule_txnow(session);
+	}
+
+	/* as soon as it's inserted, things can go fast
+	 * protect against a long delay
+	 * between spin_unlock & next statement
+	 * so, only release here, at the end
+	 */
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_dpo(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	pgn_t pgn;
+	const u8 *dat = skb->data;
+
+	pgn = j1939xtp_ctl_to_pgn(dat);
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (!session) {
+		pr_info("%s: %s\n", __func__, "no connection found");
+		return;
+	}
+
+	if (session->cb->pgn != pgn) {
+		pr_info("%s: different pgn\n", __func__);
+		j1939xtp_tx_abort(skb, 1, 1, ABORT_BUSY, pgn);
+		j1939session_cancel(session, ABORT_BUSY);
+		put_session(session); /* ~j1939tp_find */
+		return;
+	}
+
+	/* transmitted without problems */
+	session->pkt.dpo = j1939etp_ctl_to_packet(skb->data);
+	session->last_cmd = dat[0];
+	j1939tp_set_rxtimeout(session, 750);
+	put_session(session); /* ~j1939tp_find */
+}
+
+static void j1939xtp_rx_dat(struct sk_buff *skb, int extd)
+{
+	struct session *session;
+	const u8 *dat;
+	u8 *tpdat;
+	int offset;
+	int nbytes;
+	int final;
+	int do_cts_eof;
+	int packet;
+
+	session = j1939tp_find(sessionq(extd), skb, 0);
+	if (!session) {
+		pr_info("%s:%s\n", __func__, "no connection found");
+		return;
+	}
+	dat = skb->data;
+	if (skb->len <= 1)
+		/* makes no sense */
+		goto strange_packet_unlocked;
+
+	session_lock(session);
+
+	switch (session->last_cmd) {
+	case 0xff:
+		break;
+	case etp_cmd_dpo:
+		if (extd)
+			break;
+	case tp_cmd_bam:
+	case tp_cmd_cts:
+		if (!extd)
+			break;
+	default:
+		pr_info("%s: last %02x\n", __func__,
+			session->last_cmd);
+		goto strange_packet;
+	}
+
+	packet = (dat[0] - 1 + session->pkt.dpo);
+	offset = packet * 7;
+	if ((packet > session->pkt.total) ||
+	    (session->pkt.done + 1) > session->pkt.total) {
+		pr_info("%s: should have been completed\n", __func__);
+		goto strange_packet;
+	}
+	nbytes = session->skb->len - offset;
+	if (nbytes > 7)
+		nbytes = 7;
+	if ((nbytes <= 0) || ((nbytes + 1) > skb->len)) {
+		pr_info("%s: nbytes %i, len %i\n", __func__, nbytes,
+			skb->len);
+		goto strange_packet;
+	}
+	tpdat = session->skb->data;
+	memcpy(&tpdat[offset], &dat[1], nbytes);
+	if (packet == session->pkt.done)
+		++session->pkt.done;
+
+	if (!extd && j1939cb_is_broadcast(session->cb)) {
+		final = session->pkt.done >= session->pkt.total;
+		do_cts_eof = 0;
+	} else {
+		final = 0; /* never final, an EOF must follow */
+		do_cts_eof = (session->pkt.done >= session->pkt.last);
+	}
+	session_unlock(session);
+	if (final) {
+		j1939session_completed(session);
+	} else if (do_cts_eof) {
+		j1939tp_set_rxtimeout(session, 1250);
+		if (j1939tp_im_receiver(session->skb))
+			j1939session_schedule_txnow(session);
+	} else {
+		j1939tp_set_rxtimeout(session, 250);
+	}
+	session->last_cmd = 0xff;
+	put_session(session); /* ~j1939tp_find */
+	return;
+
+ strange_packet:
+	/* unlock session (spinlock) before trying to send */
+	session_unlock(session);
+ strange_packet_unlocked:
+	j1939session_cancel(session, ABORT_FAULT);
+	put_session(session); /* ~j1939tp_find */
+}
+
+/* transmit function */
+static int j1939tp_txnext(struct session *session)
+{
+	u8 dat[8];
+	const u8 *tpdat;
+	int ret, offset, pkt_done, pkt_end;
+	unsigned int pkt, len, pdelay;
+
+	memset(dat, 0xff, sizeof(dat));
+	get_session(session); /* do not loose it */
+
+	switch (session->last_cmd) {
+	case 0:
+		if (!j1939tp_im_transmitter(session->skb))
+			break;
+		dat[1] = (session->skb->len >> 0);
+		dat[2] = (session->skb->len >> 8);
+		dat[3] = session->pkt.total;
+		if (session->extd) {
+			dat[0] = etp_cmd_rts;
+			dat[1] = (session->skb->len >> 0);
+			dat[2] = (session->skb->len >> 8);
+			dat[3] = (session->skb->len >> 16);
+			dat[4] = (session->skb->len >> 24);
+		} else if (j1939cb_is_broadcast(session->cb)) {
+			dat[0] = tp_cmd_bam;
+			/* fake cts for broadcast */
+			session->pkt.tx = 0;
+		} else {
+			dat[0] = tp_cmd_rts;
+			dat[4] = dat[3];
+		}
+		if (dat[0] == session->last_txcmd)
+			/* done already */
+			break;
+		ret = j1939tp_tx_ctl(session, 0, dat);
+		if (ret < 0)
+			goto failed;
+		session->last_txcmd = dat[0];
+
+
+		/* must lock? */
+		if (tp_cmd_bam == dat[0])
+		{
+			//printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+			//printk("DEBUG: Calling j1939tp_schedule_txtimer\n");
+			//Use  50 ms delay
+			if(j1939cb_use_bamdelay(session->cb))
+			{
+				//printk("DEBUG: Using 50 ms delay\n");
+				j1939tp_schedule_txtimer(session, 50);
+			}
+			//Don't use bam delay
+			else
+			{
+				//printk("DEBUG: Using 1 ms delay\n");
+
+				//Use 1 ms delay instead
+				j1939tp_schedule_txtimer(session, 1);
+			}
+		}
+
+		j1939tp_set_rxtimeout(session, 1250);
+		break;
+	case tp_cmd_rts:
+	case etp_cmd_rts: /* fallthrough */
+		if (!j1939tp_im_receiver(session->skb))
+			break;
+ tx_cts:
+		ret = 0;
+		len = session->pkt.total - session->pkt.done;
+		len = min(max(len, session->pkt.block), block ?: 255);
+
+		if (session->extd) {
+			pkt = session->pkt.done + 1;
+			dat[0] = etp_cmd_cts;
+			dat[1] = len;
+			dat[2] = (pkt >> 0);
+			dat[3] = (pkt >> 8);
+			dat[4] = (pkt >> 16);
+		} else {
+			dat[0] = tp_cmd_cts;
+			dat[1] = len;
+			dat[2] = session->pkt.done + 1;
+		}
+		if (dat[0] == session->last_txcmd)
+			/* done already */
+			break;
+		ret = j1939tp_tx_ctl(session, 1, dat);
+		if (ret < 0)
+			goto failed;
+		if (len)
+			/* only mark cts done when len is set */
+			session->last_txcmd = dat[0];
+		j1939tp_set_rxtimeout(session, 1250);
+		break;
+	case etp_cmd_cts:
+		if (j1939tp_im_transmitter(session->skb) && session->extd &&
+		    (etp_cmd_dpo != session->last_txcmd)) {
+			/* do dpo */
+			dat[0] = etp_cmd_dpo;
+			session->pkt.dpo = session->pkt.done;
+			pkt = session->pkt.dpo;
+			dat[1] = session->pkt.last - session->pkt.done;
+			dat[2] = (pkt >> 0);
+			dat[3] = (pkt >> 8);
+			dat[4] = (pkt >> 16);
+			ret = j1939tp_tx_ctl(session, 0, dat);
+			if (ret < 0)
+				goto failed;
+			session->last_txcmd = dat[0];
+			j1939tp_set_rxtimeout(session, 1250);
+			session->pkt.tx = session->pkt.done;
+		}
+		/* fallthrough */
+	case tp_cmd_cts: /* fallthrough */
+	case 0xff: /* did some data */			/* FIXME: let David Jander recheck this */
+	case etp_cmd_dpo: /* fallthrough */
+		if ((session->extd || !j1939cb_is_broadcast(session->cb)) &&
+		    j1939tp_im_receiver(session->skb)) {
+			if (session->pkt.done >= session->pkt.total) {
+				if (session->extd) {
+					dat[0] = etp_cmd_eof;
+					dat[1] = session->skb->len >> 0;
+					dat[2] = session->skb->len >> 8;
+					dat[3] = session->skb->len >> 16;
+					dat[4] = session->skb->len >> 24;
+				} else {
+					dat[0] = tp_cmd_eof;
+					dat[1] = session->skb->len;
+					dat[2] = session->skb->len >> 8;
+					dat[3] = session->pkt.total;
+				}
+				if (dat[0] == session->last_txcmd)
+					/* done already */
+					break;
+				ret = j1939tp_tx_ctl(session, 1, dat);
+				if (ret < 0)
+					goto failed;
+				session->last_txcmd = dat[0];
+				j1939tp_set_rxtimeout(session, 1250);
+				/* wait for the EOF packet to come in */
+				break;
+			} else if (session->pkt.done >= session->pkt.last) {
+				session->last_txcmd = 0;
+				goto tx_cts;
+			}
+		}
+	case tp_cmd_bam: /* fallthrough */
+		if (!j1939tp_im_transmitter(session->skb))
+			break;
+		tpdat = session->skb->data;
+		ret = 0;
+		pkt_done = 0;
+		pkt_end = (!session->extd && j1939cb_is_broadcast(session->cb))
+			? session->pkt.total : session->pkt.last;
+
+		while (session->pkt.tx < pkt_end) {
+			dat[0] = session->pkt.tx - session->pkt.dpo + 1;
+			offset = session->pkt.tx * 7;
+			len = session->skb->len - offset;
+			if (len > 7)
+				len = 7;
+			memcpy(&dat[1], &tpdat[offset], len);
+			ret = j1939tp_tx_dat(session->skb, session->extd,
+					     dat, len + 1);
+			if (ret < 0)
+				break;
+			session->last_txcmd = 0xff;
+			++pkt_done;
+			++session->pkt.tx;
+
+			//Old
+			//pdelay = j1939cb_is_broadcast(session->cb) ?  50 : packet_delay;
+
+			if(j1939cb_is_broadcast(session->cb) && j1939cb_use_bamdelay(session->cb))
+			{
+				pdelay = 50;
+			}
+			else
+			{
+				pdelay = packet_delay;
+			}
+			//printk("DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+			//printk("DEBUG: pdelay: %d\n",pdelay);
+
+			if ((session->pkt.tx < session->pkt.total) && pdelay) {
+				j1939tp_schedule_txtimer(session, pdelay);
+				break;
+			}
+		}
+		if (pkt_done)
+			j1939tp_set_rxtimeout(session, 250);
+		if (ret)
+			goto failed;
+		break;
+	}
+	put_session(session);
+	return 0;
+ failed:
+	put_session(session);
+	return ret;
+}
+
+static void j1939tp_txtask(unsigned long val)
+{
+	struct session *session = (void *)val;
+	int ret;
+
+	get_session(session);
+	ret = j1939tp_txnext(session);
+	if (ret < 0)
+		j1939tp_schedule_txtimer(session, retry_ms ?: 20);
+	put_session(session);
+}
+
+static inline int j1939tp_tx_initial(struct session *session)
+{
+	int ret;
+
+	get_session(session);
+	ret = j1939tp_txnext(session);
+	/* set nonblocking for further packets */
+	session->cb->msg_flags |= MSG_DONTWAIT;
+	put_session(session);
+	return ret;
+}
+
+/* this call is to be used as probe within wait_event_xxx() */
+static int j1939session_insert(struct session *session)
+{
+	struct session *pending;
+
+	sessionlist_lock();
+	pending = _j1939tp_find(sessionq(session->extd), session->skb, 0);
+	if (pending)
+		/* revert the effect of find() */
+		put_session(pending);
+	else
+		list_add_tail(&session->list, sessionq(session->extd));
+	sessionlist_unlock();
+	return pending ? 0 : 1;
+}
+
+/* j1939 main intf */
+int j1939_send_transport(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	struct session *session;
+	int ret;
+	struct j1939_priv *priv;
+
+	if ((tp_pgn_dat == cb->pgn) || (tp_pgn_ctl == cb->pgn) ||
+	    (etp_pgn_dat == cb->pgn) || (etp_pgn_ctl == cb->pgn))
+		/* avoid conflict */
+		return -EDOM;
+	else if ((skb->len > MAX_ETP_PACKET_SIZE) ||
+		 (max_packet_size && (skb->len > max_packet_size)))
+		return -EMSGSIZE;
+
+	if (skb->len > MAX_TP_PACKET_SIZE) {
+		if (j1939cb_is_broadcast(cb))
+			return -EDESTADDRREQ;
+	}
+
+	/* fill in addresses from names */
+	ret = j1939_fixup_address_claim(skb);
+	if (unlikely(ret))
+		return ret;
+
+	/* fix dstflags, it may be used there soon */
+	priv = j1939_priv_find(can_skb_prv(skb)->ifindex);
+	if (!priv)
+		return -EINVAL;
+	if (!j1939_address_is_valid(cb->dstaddr) ||
+	    (j1939_address_is_unicast(cb->dstaddr) &&
+	     priv->ents[cb->dstaddr].nusers))
+		cb->dstflags |= ECU_LOCAL;
+	put_j1939_priv(priv);
+	/* src is always local, I'm sending ... */
+	cb->srcflags |= ECU_LOCAL;
+
+	/* prepare new session */
+	session = j1939session_new(skb);
+	if (!session)
+		return -ENOMEM;
+
+	session->skb_iif = can_skb_prv(skb)->ifindex;
+	session->extd = (skb->len > MAX_TP_PACKET_SIZE) ? EXTENDED : REGULAR;
+	session->transmission = 1;
+	session->pkt.total = (skb->len + 6) / 7;
+	session->pkt.block = session->extd ? 255 :
+		min(block ?: 255, session->pkt.total);
+	if (j1939cb_is_broadcast(session->cb))
+		/* set the end-packet for broadcast */
+		session->pkt.last = session->pkt.total;
+
+	/* insert into queue, but avoid collision with pending session */
+	if (session->cb->msg_flags & MSG_DONTWAIT)
+		ret = j1939session_insert(session) ? 0 : -EAGAIN;
+	else
+		ret = wait_event_interruptible(tp_wait,
+					       j1939session_insert(session));
+	if (ret < 0)
+		goto failed;
+
+	ret = j1939tp_tx_initial(session);
+	if (!ret)
+		/* transmission started */
+		return ret;
+	sessionlist_lock();
+	list_del_init(&session->list);
+	sessionlist_unlock();
+ failed:
+	/* hide the skb from j1939session_drop, as it would
+	 * kfree_skb, but our caller will kfree_skb(skb) too.
+	 */
+	session->skb = NULL;
+	j1939session_drop(session);
+	return ret;
+}
+
+int j1939_recv_transport(struct sk_buff *skb)
+{
+	struct j1939_sk_buff_cb *cb = (void *)skb->cb;
+	const u8 *dat;
+
+	switch (cb->pgn) {
+	case etp_pgn_dat:
+		j1939xtp_rx_dat(skb, EXTENDED);
+		break;
+	case etp_pgn_ctl:
+		if (skb->len < 8) {
+			j1939xtp_rx_bad_message(skb, EXTENDED);
+			break;
+		}
+		dat = skb->data;
+		switch (*dat) {
+		case etp_cmd_rts:
+			j1939xtp_rx_rts(skb, EXTENDED);
+			break;
+		case etp_cmd_cts:
+			j1939xtp_rx_cts(skb, EXTENDED);
+			break;
+		case etp_cmd_dpo:
+			j1939xtp_rx_dpo(skb, EXTENDED);
+			break;
+		case etp_cmd_eof:
+			j1939xtp_rx_eof(skb, EXTENDED);
+			break;
+		case etp_cmd_abort:
+			j1939xtp_rx_abort(skb, EXTENDED);
+			break;
+		default:
+			j1939xtp_rx_bad_message(skb, EXTENDED);
+			break;
+		}
+		break;
+	case tp_pgn_dat:
+		j1939xtp_rx_dat(skb, REGULAR);
+		break;
+	case tp_pgn_ctl:
+		if (skb->len < 8) {
+			j1939xtp_rx_bad_message(skb, REGULAR);
+			break;
+		}
+		dat = skb->data;
+		switch (*dat) {
+		case tp_cmd_bam:
+		case tp_cmd_rts:
+			j1939xtp_rx_rts(skb, REGULAR);
+			break;
+		case tp_cmd_cts:
+			j1939xtp_rx_cts(skb, REGULAR);
+			break;
+		case tp_cmd_eof:
+			j1939xtp_rx_eof(skb, REGULAR);
+			break;
+		case tp_cmd_abort:
+			j1939xtp_rx_abort(skb, REGULAR);
+			break;
+		default:
+			j1939xtp_rx_bad_message(skb, REGULAR);
+			break;
+		}
+		break;
+	default:
+		return 0; /* no problem */
+	}
+	return 1; /* "I processed the message" */
+}
+
+static struct session *j1939session_fresh_new(int size,
+					      struct sk_buff *rel_skb,
+					      pgn_t pgn)
+{
+	struct sk_buff *skb;
+	struct j1939_sk_buff_cb *cb;
+	struct session *session;
+
+	/* this SKB is allocated without headroom for CAN skb's.
+	 * This may not pose a problem, this SKB will never
+	 * enter generic CAN functions
+	 */
+	skb = alloc_skb(size, GFP_ATOMIC);
+	if (!skb)
+		return NULL;
+
+	cb = (void *)skb->cb;
+	memcpy(cb, rel_skb->cb, sizeof(*cb));
+	fix_cb(cb);
+	cb->pgn = pgn;
+
+	session = j1939session_new(skb);
+	if (!session) {
+		kfree(skb);
+		return NULL;
+	}
+	session->skb_iif = rel_skb->skb_iif;
+	skb->dev = rel_skb->dev;
+
+	/* alloc data area */
+	skb_put(skb, size);
+	return session;
+}
+
+static struct session *j1939session_new(struct sk_buff *skb)
+{
+	struct session *session;
+
+	session = kzalloc(sizeof(*session), gfp_any());
+	if (!session)
+		return NULL;
+	INIT_LIST_HEAD(&session->list);
+	spin_lock_init(&session->lock);
+	session->skb = skb;
+
+	session->cb = (void *)session->skb->cb;
+	hrtimer_init(&session->txtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	session->txtimer.function = j1939tp_txtimer;
+	hrtimer_init(&session->rxtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	session->rxtimer.function = j1939tp_rxtimer;
+	tasklet_init(&session->txtask, j1939tp_txtask, (unsigned long)session);
+	tasklet_init(&session->rxtask, j1939tp_rxtask, (unsigned long)session);
+	return session;
+}
+
+int j1939tp_rmdev_notifier(struct net_device *netdev)
+{
+	struct session *session, *saved;
+
+	sessionlist_lock();
+	list_for_each_entry_safe(session, saved, &tp_sessionq, list) {
+		if (session->skb_iif != netdev->ifindex)
+			continue;
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	list_for_each_entry_safe(session, saved, &tp_extsessionq, list) {
+		if (session->skb_iif != netdev->ifindex)
+			continue;
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	sessionlist_unlock();
+	return NOTIFY_DONE;
+}
+
+/* PROC */
+static int j1939tp_proc_show_session(struct seq_file *sqf,
+				     struct session *session)
+{
+	seq_printf(sqf, "%i", session->skb_iif);
+	if (session->cb->srcname)
+		seq_printf(sqf, "\t%016llx", session->cb->srcname);
+	else
+		seq_printf(sqf, "\t%02x", session->cb->srcaddr);
+	if (session->cb->dstname)
+		seq_printf(sqf, "\t%016llx", session->cb->dstname);
+	else if (j1939_address_is_unicast(session->cb->dstaddr))
+		seq_printf(sqf, "\t%02x", session->cb->dstaddr);
+	else
+		seq_puts(sqf, "\t-");
+	seq_printf(sqf, "\t%05x\t%u/%u\n", session->cb->pgn,
+		   session->pkt.done * 7, session->skb->len);
+	return 0;
+}
+
+static int j1939tp_proc_show(struct seq_file *sqf, void *v)
+{
+	struct session *session;
+
+	seq_puts(sqf, "iface\tsrc\tdst\tpgn\tdone/total\n");
+	sessionlist_lock();
+	list_for_each_entry(session, &tp_sessionq, list)
+		j1939tp_proc_show_session(sqf, session);
+	list_for_each_entry(session, &tp_extsessionq, list)
+		j1939tp_proc_show_session(sqf, session);
+	sessionlist_unlock();
+	return 0;
+}
+
+static int j1939tp_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, j1939tp_proc_show, NULL);
+}
+
+static const struct file_operations j1939tp_proc_ops = {
+	.owner = THIS_MODULE,
+	.open = j1939tp_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static struct ctl_table canj1939_sysctl_table[] = {
+	{
+		.procname	= "transport_burst_count",
+		.data		= &block,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &block_min,
+		.extra2		= &block_max,
+	},
+	{
+		.procname	= "transport_max_size",
+		.data		= &max_packet_size,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &max_size_min,
+		.extra2		= &max_size_max,
+	},
+	{
+		.procname	= "transport_retry_time",
+		.data		= &retry_ms,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &retry_min,
+		.extra2		= &retry_max,
+	},
+	{
+		.procname	= "transport_packet_delay",
+		.data		= &packet_delay,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &packet_delay_min,
+		.extra2		= &packet_delay_max,
+	},
+	{
+		.procname	= "transport_padding",
+		.data		= &padding,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &padding_min,
+		.extra2		= &padding_max,
+	},
+	{},
+};
+
+static struct ctl_table_header *sysctl_hdr;
+
+/* module init */
+int __init j1939tp_module_init(void)
+{
+	if (!proc_create("transport", 0444, j1939_procdir, &j1939tp_proc_ops))
+		return -ENOMEM;
+
+	sysctl_hdr = register_net_sysctl(&init_net, "net/can-j1939",
+			canj1939_sysctl_table);
+	if (!sysctl_hdr) {
+		remove_proc_entry("transport", j1939_procdir);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void j1939tp_module_exit(void)
+{
+	struct session *session, *saved;
+
+	wake_up_all(&tp_wait);
+
+	unregister_net_sysctl_table(sysctl_hdr);
+	remove_proc_entry("transport", j1939_procdir);
+	sessionlist_lock();
+	list_for_each_entry_safe(session, saved, &tp_extsessionq, list) {
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	list_for_each_entry_safe(session, saved, &tp_sessionq, list) {
+		list_del_init(&session->list);
+		put_session(session);
+	}
+	sessionlist_unlock();
+	flush_scheduled_work();
+}
diff --git a/net/can/raw.c b/net/can/raw.c
index 6dc546a..d736513 100644
--- a/net/can/raw.c
+++ b/net/can/raw.c
@@ -393,7 +393,7 @@ static int raw_bind(struct socket *sock, struct sockaddr *uaddr, int len)
 	int err = 0;
 	int notify_enetdown = 0;
 
-	if (len < sizeof(*addr))
+	if (len < REQUIRED_SIZE(*addr, can_ifindex))
 		return -EINVAL;
 
 	lock_sock(sk);
@@ -723,7 +723,7 @@ static int raw_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	if (msg->msg_name) {
 		DECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);
 
-		if (msg->msg_namelen < sizeof(*addr))
+		if (msg->msg_namelen < REQUIRED_SIZE(*addr, can_ifindex))
 			return -EINVAL;
 
 		if (addr->can_family != AF_CAN)
