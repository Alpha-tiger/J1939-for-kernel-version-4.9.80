diff --git a/include/uapi/linux/can/j1939.h b/include/uapi/linux/can/j1939.h
index 4d0d23e..6c974ba 100644
--- a/include/uapi/linux/can/j1939.h
+++ b/include/uapi/linux/can/j1939.h
@@ -59,6 +59,7 @@ enum {
 	SO_J1939_PROMISC = 2,	/* set/clr promiscuous mode */
 	SO_J1939_RECV_OWN = 3,
 	SO_J1939_SEND_PRIO = 4,
+	SO_J1939_BAM_DELAY_DISABLE = 5, //Enable/Disable 50 ms delay for BAM messages
 };
 
 enum {
diff --git a/net/can/j1939/j1939-priv.h b/net/can/j1939/j1939-priv.h
index 5ef7b37..d712c26 100644
--- a/net/can/j1939/j1939-priv.h
+++ b/net/can/j1939/j1939-priv.h
@@ -222,6 +222,11 @@ struct j1939_sk_buff_cb {
 
 #define ECU_LOCAL 1
 
+	/* Flags for modifying the transport protocol*/
+	int tpflags;
+
+#define BAM_NODELAY 1
+
 	/* for tx, MSG_SYN will be used to sync on sockets */
 	int msg_flags;
 
@@ -235,6 +240,13 @@ struct j1939_sk_buff_cb {
 #define J1939_MSG_RESERVED MSG_SYN
 #define J1939_MSG_SYNC MSG_SYN
 
+//Check if we want to disable the normal BAM 50 ms delay
+static inline int j1939cb_use_bamdelay(const struct j1939_sk_buff_cb *skcb)
+{
+	return !(skcb->tpflags & BAM_NODELAY);
+}
+
+
 static inline int j1939cb_is_broadcast(const struct j1939_sk_buff_cb *skcb)
 {
 	return (!skcb->dstname && (skcb->dstaddr == 0xff));
diff --git a/net/can/j1939/main.c b/net/can/j1939/main.c
index 3f4b018..8a02edb 100644
--- a/net/can/j1939/main.c
+++ b/net/can/j1939/main.c
@@ -129,8 +129,10 @@ int j1939_send(struct sk_buff *skb)
 	struct can_frame *cf;
 
 	if (skb->len > 8)
+	{
 		/* re-route via transport protocol */
 		return j1939_send_transport(skb);
+	}
 
 	/* apply sanity checks */
 	skcb->pgn &= (pgn_is_pdu1(skcb->pgn)) ? 0x3ff00 : 0x3ffff;
diff --git a/net/can/j1939/socket.c b/net/can/j1939/socket.c
index 41d59dd..ae77e32 100644
--- a/net/can/j1939/socket.c
+++ b/net/can/j1939/socket.c
@@ -39,6 +39,7 @@ struct j1939_sock {
 #define JSK_CONNECTED BIT(1)
 #define PROMISC BIT(2)
 #define RECV_OWN BIT(3)
+#define JSK_BAM_DELAY BIT(4)
 
 	int ifindex_started; /* ifindex of netdev */
 
@@ -538,6 +539,9 @@ static int j1939sk_setsockopt(struct socket *sock, int level, int optname,
 		jsk->sk.sk_priority = j1939_to_sk_priority(tmp);
 		release_sock(&jsk->sk);
 		return 0;
+	case SO_J1939_BAM_DELAY_DISABLE:
+		//Enables/Disables delay
+		return j1939sk_setsockopt_flag(jsk, optval, optlen, JSK_BAM_DELAY);
 	default:
 		return -ENOPROTOOPT;
 	}
@@ -572,6 +576,9 @@ static int j1939sk_getsockopt(struct socket *sock, int level, int optname,
 	case SO_J1939_SEND_PRIO:
 		tmp = j1939_prio(jsk->sk.sk_priority);
 		break;
+	case SO_J1939_BAM_DELAY_DISABLE:
+		tmp = (jsk->state & JSK_BAM_DELAY) ? 1 : 0;
+		break;
 	default:
 		ret = -ENOPROTOOPT;
 		goto no_copy;
@@ -714,6 +721,8 @@ static int j1939sk_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
 	skcb->priority = j1939_prio(jsk->sk.sk_priority);
 	skcb->srcaddr = jsk->addr.sa;
 	skcb->dstaddr = jsk->addr.da;
+	//Check if delay has been disabled
+	skcb->tpflags = (jsk->state & JSK_BAM_DELAY);
 
 	if (msg->msg_name) {
 		struct sockaddr_can *addr = msg->msg_name;
diff --git a/net/can/j1939/transport.c b/net/can/j1939/transport.c
index 5f23fcf..60bb681 100644
--- a/net/can/j1939/transport.c
+++ b/net/can/j1939/transport.c
@@ -975,8 +975,10 @@ static int j1939tp_txnext(struct session *session)
 			goto failed;
 		session->last_txcmd = dat[0];
 		/* must lock? */
-		if (tp_cmd_bam == dat[0])
+		if (tp_cmd_bam == dat[0] && j1939cb_use_bamdelay(session->cb))
+		{
 			j1939tp_schedule_txtimer(session, 50);
+		}
 		j1939tp_set_rxtimeout(session, 1250);
 		break;
 	case tp_cmd_rts:
@@ -1086,8 +1088,9 @@ static int j1939tp_txnext(struct session *session)
 			session->last_txcmd = 0xff;
 			++pkt_done;
 			++session->pkt.tx;
-			pdelay = j1939cb_is_broadcast(session->cb) ?  50 :
-				packet_delay;
+
+			pdelay = j1939cb_is_broadcast(session->cb) ? (j1939cb_use_bamdelay(session->cb)? 50 :  packet_delay): packet_delay;
+
 			if ((session->pkt.tx < session->pkt.total) && pdelay) {
 				j1939tp_schedule_txtimer(session, pdelay);
 				break;
